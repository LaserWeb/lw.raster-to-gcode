{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.raster-to-gcode.js","webpack:///webpack/bootstrap f14adec08ca935f229e1","webpack:///./raster-to-gcode.js","webpack:///../~/lw.canvas-grid/dist/lw.canvas-grid.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","RasterToGcode","undefined","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_lw","_lw2","_CanvasGrid","settings","assign","ppi","beamSize","beamRange","min","max","beamPower","feedRate","feedUnit","offsets","X","Y","trimLine","joinPixel","burnWhite","verboseG","diagonal","precision","S","nonBlocking","filters","smoothing","brightness","contrast","gamma","grayscale","shadesOfGray","progress","progressContext","done","doneContext","_this","ppm","parseFloat","toFixed","scaleRatio","gcode","currentLine","lastCommands","outputSize","width","height","G1","G0","beamOffset","realBeamRange","on","size","_addHeader","_scanDiagonally","_scanHorizontally","push","options","splice","join","name","commands","Array","slice","arguments","command","line","il","_command","apply","x","y","defaultValue","pixel","getPixel","gray","error","index","point","G","s","_mapPixelPower","first","lastWhite","last","lastColored","shift","pop","points","power","reversed","pixels","overscan","firstPoint","lastPoint","rightPoint","leftPoint","unshift","_trimCurrentLine","_reduceCurrentLine","_overscanCurrentLine","reverse","_getPoint","_this2","w","h","computeCurrentLine","_getPixelPower","percent","lastPercent","processCurrentLine","_processCurrentLine","Math","round","_onProgress","processNextLine","setTimeout","_onDone","_this3","totalLines","lineNum","event","callback","context","_this4","method","toUpperCase","Error","e","t","a","n","CanvasGrid","o","r","l","cellSize","cols","rows","file","image","url","canvas","File","loadFromFile","Image","loadFromImage","URL","loadFromURL","trim","Promise","reject","onload","then","_processImage","catch","onerror","src","_loadImage","createObjectURL","ceil","u","d","document","createElement","getContext","fillStyle","fillRect","drawImage","parseInt","isNaN","getImageData","data","color","g","b","grid","col","row","coords","exp","log","indexOf","imageSmoothingEnabled","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","oImageSmoothingEnabled","f","putImageData","canvasFilters"],"mappings":"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","file":"lw.raster-to-gcode.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"RasterToGcode\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RasterToGcode\"] = factory();\n\telse\n\t\troot[\"RasterToGcode\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"RasterToGcode\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RasterToGcode\"] = factory();\n\telse\n\t\troot[\"RasterToGcode\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.RasterToGcode = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _lw = __webpack_require__(2);\n\t\n\tvar _lw2 = _interopRequireDefault(_lw);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// RasterToGcode class\n\tvar RasterToGcode = function (_CanvasGrid) {\n\t    _inherits(RasterToGcode, _CanvasGrid);\n\t\n\t    // Class constructor...\n\t    function RasterToGcode(settings) {\n\t        _classCallCheck(this, RasterToGcode);\n\t\n\t        // Defaults settings\n\t        settings = Object.assign({\n\t            ppi: 254, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\t\n\t            beamSize: 0.1, // Beam size in millimeters\n\t            beamRange: { min: 0, max: 1 }, // Beam power range (Firmware value)\n\t            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n\t            feedRate: 1500, // Feed rate in mm/min (F value)\n\t            feedUnit: 'mm/min', // Feed rate unit [mm/min, mm/sec]\n\t\n\t            offsets: { X: 0, Y: 0 }, // Global coordinates offsets\n\t            trimLine: true, // Trim trailing white pixels\n\t            joinPixel: true, // Join consecutive pixels with same intensity\n\t            burnWhite: true, // [true = G1 S0 | false = G0] on inner white pixels\n\t            verboseG: false, // Output verbose GCode (print each commands)\n\t            diagonal: false, // Go diagonally (increase the distance between points)\n\t\n\t            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\t\n\t            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\t\n\t            filters: {\n\t                smoothing: 0, // Smoothing the input image ?\n\t                brightness: 0, // Image brightness [-255 to +255]\n\t                contrast: 0, // Image contrast [-255 to +255]\n\t                gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t                grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t                shadesOfGray: 256 // Number of shades of gray [2-256]\n\t            },\n\t\n\t            progress: null, // On progress callbacks\n\t            progressContext: null, // On progress callback context\n\t\n\t            done: null, // On done callback\n\t            doneContext: null // On done callback context\n\t        }, settings || {});\n\t\n\t        // Init properties\n\t\n\t        // Calculate PPM = Pixel Per Millimeters\n\t        var _this = _possibleConstructorReturn(this, (RasterToGcode.__proto__ || Object.getPrototypeOf(RasterToGcode)).call(this, settings));\n\t\n\t        _this.ppm = 2540 / (_this.ppi * 100);\n\t        _this.ppm = parseFloat(_this.ppm.toFixed(10));\n\t\n\t        // Calculate scale ratio\n\t        _this.scaleRatio = _this.ppm / _this.beamSize;\n\t\n\t        // State...\n\t        _this.gcode = null;\n\t        _this.currentLine = null;\n\t        _this.lastCommands = null;\n\t\n\t        // Output size in millimeters\n\t        _this.outputSize = { width: 0, height: 0 };\n\t\n\t        // G0 command\n\t        _this.G1 = ['G', 1];\n\t        _this.G0 = ['G', _this.burnWhite ? 1 : 0];\n\t\n\t        // Calculate beam offset\n\t        _this.beamOffset = _this.beamSize * 1000 / 2000;\n\t\n\t        // Calculate real beam range\n\t        _this.realBeamRange = {\n\t            min: _this.beamRange.max / 100 * _this.beamPower.min,\n\t            max: _this.beamRange.max / 100 * _this.beamPower.max\n\t        };\n\t\n\t        // Adjuste feed rate to mm/min\n\t        if (_this.feedUnit === 'mm/sec') {\n\t            _this.feedRate *= 60;\n\t        }\n\t\n\t        // register user callbacks\n\t        _this.progress && _this.on('progress', _this.progress, _this.progressContext);\n\t        _this.done && _this.on('done', _this.done, _this.doneContext);\n\t        return _this;\n\t    }\n\t\n\t    // Process image\n\t\n\t\n\t    _createClass(RasterToGcode, [{\n\t        key: '_processImage',\n\t        value: function _processImage() {\n\t            // Call parent method\n\t            _get(RasterToGcode.prototype.__proto__ || Object.getPrototypeOf(RasterToGcode.prototype), '_processImage', this).call(this);\n\t\n\t            // Calculate output size\n\t            this.outputSize = {\n\t                width: this.size.width * (this.beamSize * 1000) / 1000,\n\t                height: this.size.height * (this.beamSize * 1000) / 1000\n\t            };\n\t        }\n\t\n\t        // Process image and return gcode string\n\t\n\t    }, {\n\t        key: 'run',\n\t        value: function run(progress, done) {\n\t            // Reset state\n\t            this.gcode = [];\n\t            this.lastCommands = {};\n\t            this.currentLine = null;\n\t\n\t            // register user callbacks\n\t            progress && this.on('progress', progress);\n\t            done && this.on('done', done);\n\t\n\t            // Add gcode header\n\t            this._addHeader();\n\t\n\t            // Scan type ?\n\t            if (this.diagonal) {\n\t                this._scanDiagonally();\n\t            } else {\n\t                this._scanHorizontally();\n\t            }\n\t\n\t            if (!this.nonBlocking) {\n\t                return this.gcode;\n\t            }\n\t        }\n\t    }, {\n\t        key: '_addHeader',\n\t        value: function _addHeader() {\n\t            // Base headers\n\t            this.gcode.push('; Generated by LaserWeb (lw.raster-to-gcode.js)', '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm', '; Resolution : ' + this.ppm + ' PPM - ' + this.ppi + ' PPI', '; Beam size  : ' + this.beamSize + ' mm', '; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max, '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %', '; Feed rate  : ' + this.feedRate + ' mm/min');\n\t\n\t            // Print activated options\n\t            var options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal'];\n\t\n\t            for (var i = options.length - 1; i >= 0; i--) {\n\t                if (!this[options[i]]) {\n\t                    options.splice(i, 1);\n\t                }\n\t            }\n\t\n\t            if (options.length) {\n\t                this.gcode.push('; Options    : ' + options.join(', '));\n\t            }\n\t\n\t            // Set feed rates\n\t            this.gcode.push('', 'G0 F' + this.feedRate, 'G1 F' + this.feedRate, '');\n\t        }\n\t\n\t        // Map S value to pixel power\n\t\n\t    }, {\n\t        key: '_mapPixelPower',\n\t        value: function _mapPixelPower(value) {\n\t            return value * (this.realBeamRange.max - this.realBeamRange.min) / 255 + this.realBeamRange.min;\n\t        }\n\t\n\t        // Compute and return a command, return null if not changed\n\t\n\t    }, {\n\t        key: '_command',\n\t        value: function _command(name, value) {\n\t            // If the value argument is an object\n\t            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n\t                // Computed commands line\n\t                var commands = Array.prototype.slice.call(arguments);\n\t                var command = void 0,\n\t                    line = [];\n\t\n\t                // for each command\n\t                for (var i = 0, il = commands.length; i < il; i++) {\n\t                    command = this._command.apply(this, commands[i]);\n\t                    command && line.push(command);\n\t                }\n\t\n\t                // Return the line if not empty\n\t                return line.length ? line.join(' ') : null;\n\t            }\n\t\n\t            // Format the value\n\t            value = value.toFixed(this.precision[name] || 0);\n\t\n\t            // If the value was changed or if verbose mode on\n\t            if (this.verboseG || value !== this.lastCommands[name]) {\n\t                this.lastCommands[name] = value;\n\t                return name + value;\n\t            }\n\t\n\t            // No change\n\t            return null;\n\t        }\n\t\n\t        // Get a pixel power value from the canvas data grid\n\t\n\t    }, {\n\t        key: '_getPixelPower',\n\t        value: function _getPixelPower(x, y, defaultValue) {\n\t            try {\n\t                // Reverse Y value since canvas as top/left origin\n\t                y = this.size.height - y - 1;\n\t\n\t                // Get pixel info\n\t                var pixel = this.getPixel(x, y);\n\t\n\t                // Reversed gray value [ 0 = white | 255 = black ]\n\t                return 255 - pixel.gray;\n\t            } catch (error) {\n\t                if (arguments.length === 3) {\n\t                    return defaultValue;\n\t                }\n\t                throw error;\n\t            }\n\t        }\n\t\n\t        // Get a point from the current line with real world coordinates\n\t\n\t    }, {\n\t        key: '_getPoint',\n\t        value: function _getPoint(index) {\n\t            // Get the point object from the current line\n\t            var point = this.currentLine[index];\n\t\n\t            // No point\n\t            if (!point) {\n\t                return null;\n\t            }\n\t\n\t            // Commands\n\t            point.G = point.s ? ['G', 1] : this.G0;\n\t            point.X = point.x * this.beamSize + this.offsets.X;\n\t            point.Y = point.y * this.beamSize + this.offsets.Y;\n\t            point.S = this._mapPixelPower(point.s);\n\t\n\t            // Offsets\n\t            if (this.diagonal) {\n\t                // Vertical offset\n\t                point.Y += this.beamSize;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                    point.Y -= this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                    point.Y += this.beamOffset;\n\t                }\n\t            } else {\n\t                // Vertical offset\n\t                point.Y += this.beamOffset;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                }\n\t            }\n\t\n\t            // Return the point\n\t            return point;\n\t        }\n\t\n\t        // Remove all trailing white spaces from the current line\n\t\n\t    }, {\n\t        key: '_trimCurrentLine',\n\t        value: function _trimCurrentLine() {\n\t            // Remove white spaces from the left\n\t            var point = this.currentLine[0];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.shift();\n\t                point = this.currentLine[0];\n\t            }\n\t\n\t            // Remove white spaces from the right\n\t            point = this.currentLine[this.currentLine.length - 2];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.pop();\n\t                point = this.currentLine[this.currentLine.length - 2];\n\t            }\n\t\n\t            // Return the new line length\n\t            return this.currentLine.length;\n\t        }\n\t\n\t        // Join pixel with same power\n\t\n\t    }, {\n\t        key: '_reduceCurrentLine',\n\t        value: function _reduceCurrentLine() {\n\t            // Line too short to be reduced\n\t            if (this.currentLine.length < 3) {\n\t                return this.currentLine.length;\n\t            }\n\t\n\t            // Extract all points exept the first one\n\t            var points = this.currentLine.splice(1);\n\t\n\t            // Get current power\n\t            var power = this.currentLine[0].p;\n\t\n\t            // For each extracted point\n\t            for (var point, i = 0, il = points.length - 1; i < il; i++) {\n\t                // Current point\n\t                point = points[i];\n\t\n\t                // On power change\n\t                if (power !== point.p) {\n\t                    this.currentLine.push(point);\n\t                }\n\t\n\t                // Update power\n\t                power = point.p;\n\t            }\n\t\n\t            // Add last point\n\t            this.currentLine.push(points[i]);\n\t        }\n\t\n\t        // Add extra white pixels at the ends\n\t\n\t    }, {\n\t        key: '_overscanCurrentLine',\n\t        value: function _overscanCurrentLine(reversed) {\n\t            // Number of pixels to add on each side\n\t            var pixels = this.overscan / this.ppm;\n\t\n\t            // Get first/last point\n\t            var firstPoint = this.currentLine[0];\n\t            var lastPoint = this.currentLine[this.currentLine.length - 1];\n\t\n\t            // Is last white/colored point ?\n\t            firstPoint.s && (firstPoint.lastWhite = true);\n\t            lastPoint.s && (lastPoint.lastColored = true);\n\t\n\t            // Reversed line ?\n\t            reversed ? lastPoint.s = 0 : firstPoint.s = 0;\n\t\n\t            // Create left/right points\n\t            var rightPoint = { x: lastPoint.x + pixels, y: lastPoint.y, s: 0, p: 0 };\n\t            var leftPoint = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 };\n\t\n\t            if (this.diagonal) {\n\t                leftPoint.y += pixels;\n\t                rightPoint.y -= pixels;\n\t            }\n\t\n\t            // Add left/right points to current line\n\t            this.currentLine.unshift(leftPoint);\n\t            this.currentLine.push(rightPoint);\n\t        }\n\t\n\t        // Process current line and return an array of GCode text lines\n\t\n\t    }, {\n\t        key: '_processCurrentLine',\n\t        value: function _processCurrentLine(reversed) {\n\t            // Trim trailing white spaces ?\n\t            if (this.trimLine && !this._trimCurrentLine()) {\n\t                // Skip empty line\n\t                return null;\n\t            }\n\t\n\t            // Join pixel with same power\n\t            if (this.joinPixel) {\n\t                this._reduceCurrentLine();\n\t            }\n\t\n\t            // Overscan ?\n\t            if (this.overscan) {\n\t                this._overscanCurrentLine(reversed);\n\t            }\n\t\n\t            // Mark first and last point on the current line\n\t            this.currentLine[0].first = true;\n\t            this.currentLine[this.currentLine.length - 1].last = true;\n\t\n\t            // Reversed line ?\n\t            if (reversed) {\n\t                this.currentLine = this.currentLine.reverse();\n\t            }\n\t\n\t            // Point index\n\t            var point = void 0,\n\t                index = 0;\n\t\n\t            // Init loop vars...\n\t            var command = void 0,\n\t                gcode = [];\n\t\n\t            // Get first point\n\t            point = this._getPoint(index);\n\t\n\t            // Move to start of the line\n\t            command = this._command(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0]);\n\t            command && gcode.push(command);\n\t\n\t            // For each point on the line\n\t            while (point) {\n\t                // Burn to next point\n\t                command = this._command(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S]);\n\t                command && gcode.push(command);\n\t\n\t                // Get next point\n\t                point = this._getPoint(++index);\n\t            }\n\t\n\t            // Return gcode commands array\n\t            if (gcode.length) {\n\t                return gcode;\n\t            }\n\t\n\t            // Empty line\n\t            return null;\n\t        }\n\t\n\t        // Parse horizontally\n\t\n\t    }, {\n\t        key: '_scanHorizontally',\n\t        value: function _scanHorizontally() {\n\t            var _this2 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine() {\n\t                // Reset current line\n\t                _this2.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // For each pixel on the line\n\t                for (x = 0; x <= w; x++) {\n\t                    // Get pixel power\n\t                    s = p = _this2._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add point to current line\n\t                    _this2.currentLine.push(point);\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this2._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(y / h * 100);\n\t                if (percent > lastPercent) {\n\t                    _this2._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this2.gcode.push.apply(_this2.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                computeCurrentLine();\n\t                processCurrentLine();\n\t\n\t                y++;\n\t\n\t                if (y < h) {\n\t                    if (_this2.nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    _this2._onDone({ gcode: _this2.gcode });\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t\n\t            // // For each image line\n\t            // for (y = 0; y < h; y++) {\n\t            //     processNextLine()\n\t            // }\n\t        }\n\t\n\t        // Parse diagonally\n\t\n\t    }, {\n\t        key: '_scanDiagonally',\n\t        value: function _scanDiagonally() {\n\t            var _this3 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var totalLines = w + h - 1;\n\t            var lineNum = 0;\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine(x, y) {\n\t                // Reset current line\n\t                _this3.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // Increment line num\n\t                lineNum++;\n\t\n\t                while (true) {\n\t                    // Y limit reached !\n\t                    if (y < -1 || y == h) {\n\t                        break;\n\t                    }\n\t\n\t                    // X limit reached !\n\t                    if (x < 0 || x > w) {\n\t                        break;\n\t                    }\n\t\n\t                    // Get pixel power\n\t                    s = p = _this3._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add the new point\n\t                    _this3.currentLine.push(point);\n\t\n\t                    // Next coords\n\t                    x++;\n\t                    y--;\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this3._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(lineNum / totalLines * 100);\n\t                if (percent > lastPercent) {\n\t                    _this3._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this3.gcode.push.apply(_this3.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                computeCurrentLine(x, y);\n\t                processCurrentLine();\n\t\n\t                if (!x) y++;else x++;\n\t\n\t                if (y === h) {\n\t                    x++;\n\t                    y--;\n\t                }\n\t\n\t                if (y < h && x < w) {\n\t                    if (_this3.nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    _this3._onDone({ gcode: _this3.gcode });\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t\n\t            // // For each image line\n\t            // for (y = 0; y < h; y++) {\n\t            //     scanDiagonalLine(x, y)\n\t            // }\n\t            //\n\t            // // For each image column (exept the first one)\n\t            // for (x = 1, y--; x < w; x++) {\n\t            //     scanDiagonalLine(x, y)\n\t            // }\n\t        }\n\t    }, {\n\t        key: '_onProgress',\n\t        value: function _onProgress(event) {\n\t            //console.log('progress:', event.percent);\n\t        }\n\t    }, {\n\t        key: '_onDone',\n\t        value: function _onDone(event) {\n\t            //console.log('done:', event.gcode.length);\n\t        }\n\t    }, {\n\t        key: 'on',\n\t        value: function on(event, callback, context) {\n\t            var _this4 = this;\n\t\n\t            var method = '_on' + event[0].toUpperCase() + event.slice(1);\n\t\n\t            if (!this[method] || typeof this[method] !== 'function') {\n\t                throw new Error('Undefined event: ' + event);\n\t            }\n\t\n\t            this[method] = function (event) {\n\t                return callback.call(context || _this4, event);\n\t            };\n\t\n\t            return this;\n\t        }\n\t    }]);\n\t\n\t    return RasterToGcode;\n\t}(_lw2.default);\n\t\n\t// Exports\n\t\n\t\n\texports.RasterToGcode = RasterToGcode;\n\texports.default = RasterToGcode;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(e,t){ true?module.exports=t():\"function\"==typeof define&&define.amd?define(\"CanvasGrid\",[],t):\"object\"==typeof exports?exports.CanvasGrid=t():e.CanvasGrid=t()}(this,function(){return function(e){function t(a){if(i[a])return i[a].exports;var n=i[a]={exports:{},id:a,loaded:!1};return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports}var i={};return t.m=e,t.c=i,t.p=\"\",t(0)}([function(e,t,i){e.exports=i(1)},function(e,t,i){\"use strict\";function a(e){return e&&e.__esModule?e:{default:e}}function n(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(t,\"__esModule\",{value:!0}),t.CanvasGrid=void 0;var o=function(){function e(e,t){for(var i=0;i<t.length;i++){var a=t[i];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(t,i,a){return i&&e(t.prototype,i),a&&e(t,a),t}}(),r=i(2),s=a(r),l=function(){function e(t){n(this,e),this.cellSize=1024,this.scaleRatio=1,this.filters={},Object.assign(this,t||{}),this.size={width:0,height:0,cols:0,rows:0},this.file=null,this.image=null,this.url=null,this.canvas=[],this.pixels=[]}return o(e,[{key:\"load\",value:function(e){return e instanceof File?this.loadFromFile(e):e instanceof Image?this.loadFromImage(e):\"string\"==typeof e||e instanceof URL?this.loadFromURL(e.trim()):Promise.reject(new Error(\"Unsupported input format.\"))}},{key:\"_loadImage\",value:function(e,t,i){var a=this,n=new Image;n.onload=function(e){a.loadFromImage(n).then(function(e){a._processImage(),i(e)}).catch(t)},n.onerror=function(i){t(new Error(\"Error reading file : \"+e))},n.src=e}},{key:\"loadFromFile\",value:function(e){var t=this;return new Promise(function(i,a){e instanceof File||a(new Error(\"Input param must be a File object.\")),t.file=e,t._loadImage(URL.createObjectURL(e),a,i)})}},{key:\"loadFromURL\",value:function(e){var t=this;return new Promise(function(i,a){e instanceof URL||\"string\"==typeof e||a(new Error(\"Input param must be a URL string or object.\"));var n=e instanceof URL?e:new URL(e);t.url=n,t._loadImage(n,a,i)})}},{key:\"loadFromImage\",value:function(e){var t=this;return new Promise(function(i,a){e instanceof Image||a(new Error(\"Input param must be a Image object.\")),t.image=e,i(t)})}},{key:\"_processImage\",value:function(){this.canvas=[],this.pixels=[];var e=Math.round(this.image.width*this.scaleRatio),t=Math.round(this.image.height*this.scaleRatio),i=Math.ceil(e/this.cellSize),a=Math.ceil(t/this.cellSize);this.size={width:e,height:t,cols:i,rows:a};var n=null,o=null,r=null,l=null,h=null,c=null,u=null,d=null,m=null;for(h=0;h<this.size.rows;h++){for(n=[],l=0;l<this.size.cols;l++)o=document.createElement(\"canvas\"),0===l||l<this.size.cols-1?o.width=this.size.width<this.cellSize?this.size.width:this.cellSize:o.width=this.size.width%this.cellSize,0===h||h<this.size.rows-1?o.height=this.size.height<this.cellSize?this.size.height:this.cellSize:o.height=this.size.height%this.cellSize,r=o.getContext(\"2d\"),r.fillStyle=\"white\",r.fillRect(0,0,o.width,o.height),d=o.width/this.scaleRatio,m=o.height/this.scaleRatio,c=l*this.cellSize/this.scaleRatio,u=h*this.cellSize/this.scaleRatio,r.drawImage(this.image,c,u,d,m,0,0,o.width,o.height),(0,s.default)(o,this.filters),n.push(o);this.canvas.push(n)}}},{key:\"getPixel\",value:function(e,t){if(e=parseInt(e),t=parseInt(t),isNaN(e)||isNaN(t))throw new Error(\"[x, y] params must be Integer.\");if(e<0||e>=this.size.width)throw new Error(\"Out of range: x = \"+e+\", max: \"+this.size.width);if(t<0||t>=this.size.height)throw new Error(\"Out of range: y = \"+t+\", max: \"+this.size.height);var i=parseInt(e/this.cellSize),a=parseInt(t/this.cellSize);i&&(e-=this.cellSize*i),a&&(t-=this.cellSize*a);var n=this.canvas[a][i],o=n.getContext(\"2d\"),r=o.getImageData(e,t,1,1).data;return{color:{r:r[0],g:r[1],b:r[2],a:r[3]},gray:(r[0]+r[1]+r[2])/3,grid:{col:i,row:a},coords:{x:e,y:t}}}}]),e}();t.CanvasGrid=l,t.default=l},function(e,t,i){!function(t,i){e.exports=i()}(this,function(){return function(e){function t(a){if(i[a])return i[a].exports;var n=i[a]={exports:{},id:a,loaded:!1};return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports}var i={};return t.m=e,t.c=i,t.p=\"\",t(0)}([function(e,t,i){e.exports=i(1)},function(e,t){\"use strict\";function i(e){return e<0?0:e>255?255:e}function a(e,t,a){void 0!==a&&(e[t]=i(e[t]+a),e[t+1]=i(e[t+1]+a),e[t+2]=i(e[t+2]+a))}function n(e,t,a){void 0!==a&&(e[t]=i(a*(e[t]-128)+128),e[t+1]=i(a*(e[t+1]-128)+128),e[t+2]=i(a*(e[t+2]-128)+128))}function o(e,t,a){void 0!==a&&(e[t]=i(Math.exp(Math.log(255*(e[t]/255))*a)),e[t+1]=i(Math.exp(Math.log(255*(e[t+1]/255))*a)),e[t+2]=i(Math.exp(Math.log(255*(e[t+2]/255))*a)))}function r(e,t,a,n){if(l.indexOf(a)===-1)throw new Error(\"Unsupported grayscale algorithm: \"+a);if(\"none\"===a)return null;var o=void 0,r=e[t],s=e[t+1],h=e[t+2];switch(a){case\"average\":o=(r+s+h)/3;break;case\"luma\":o=.3*r+.59*s+.11*h;break;case\"luma-601\":o=.299*r+.587*s+.114*h;break;case\"luma-709\":o=.2126*r+.7152*s+.0722*h;break;case\"luma-240\":o=.212*r+.701*s+.087*h;break;case\"desaturation\":o=(Math.max(r,s,h)+Math.min(r,s,h))/2;break;case\"decomposition-min\":o=Math.min(r,s,h);break;case\"decomposition-max\":o=Math.max(r,s,h);break;case\"red-chanel\":o=r;break;case\"green-chanel\":o=s;break;case\"blue-chanel\":o=h}void 0!==n&&(o=parseInt(o/n)*n),o=parseInt(o),e[t]=i(o),e[t+1]=i(o),e[t+2]=i(o)}function s(e,t){t=Object.assign({},{smoothing:!1,brightness:0,contrast:0,gamma:0,grayscale:\"none\",shadesOfGray:256},t||{});var i=e.getContext(\"2d\");void 0!==i.imageSmoothingEnabled?i.imageSmoothingEnabled=t.smoothing:(i.mozImageSmoothingEnabled=t.smoothing,i.webkitImageSmoothingEnabled=t.smoothing,i.msImageSmoothingEnabled=t.smoothing,i.oImageSmoothingEnabled=t.smoothing);var s=i.getImageData(0,0,e.width,e.height),l=s.data,h=void 0,c=void 0,u=void 0,d=void 0;0!==t.contrast&&(h=259*(t.contrast+255)/(255*(259-t.contrast))),0!==t.brightness&&(c=t.brightness),0!==t.gamma&&(u=1/t.gamma),t.shadesOfGray>1&&t.shadesOfGray<256&&(d=255/(t.shadesOfGray-1));for(var m=0,f=l.length;m<f;m+=4)a(l,m,c),n(l,m,h),o(l,m,u),r(l,m,t.grayscale,d);i.putImageData(s,0,0)}Object.defineProperty(t,\"__esModule\",{value:!0});var l=[\"none\",\"average\",\"desaturation\",\"decomposition-min\",\"decomposition-max\",\"luma\",\"luma-601\",\"luma-709\",\"luma-240\",\"red-chanel\",\"green-chanel\",\"blue-chanel\"];t.canvasFilters=s,t.default=s}])})}])});\n\t//# sourceMappingURL=lw.canvas-grid.js.map\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.raster-to-gcode.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f14adec08ca935f229e1","import CanvasGrid from 'lw.canvas-grid'\n\n// RasterToGcode class\nclass RasterToGcode extends CanvasGrid {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = Object.assign({\n            ppi: 254, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\n            beamSize : 0.1,                  // Beam size in millimeters\n            beamRange: { min: 0, max: 1 },   // Beam power range (Firmware value)\n            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n            feedRate : 1500,                 // Feed rate in mm/min (F value)\n            feedUnit : 'mm/min',             // Feed rate unit [mm/min, mm/sec]\n\n            offsets  : { X: 0, Y: 0 }, // Global coordinates offsets\n            trimLine : true,           // Trim trailing white pixels\n            joinPixel: true,           // Join consecutive pixels with same intensity\n            burnWhite: true,           // [true = G1 S0 | false = G0] on inner white pixels\n            verboseG : false,          // Output verbose GCode (print each commands)\n            diagonal : false,          // Go diagonally (increase the distance between points)\n\n            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\n            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\n            filters: {\n                smoothing   : 0,      // Smoothing the input image ?\n                brightness  : 0,      // Image brightness [-255 to +255]\n                contrast    : 0,      // Image contrast [-255 to +255]\n                gamma       : 0,      // Image gamma correction [0.01 to 7.99]\n                grayscale   : 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n                shadesOfGray: 256     // Number of shades of gray [2-256]\n            },\n\n            progress       : null, // On progress callbacks\n            progressContext: null, // On progress callback context\n\n            done       : null, // On done callback\n            doneContext: null  // On done callback context\n        }, settings || {})\n\n        // Init properties\n        super(settings)\n\n        // Calculate PPM = Pixel Per Millimeters\n        this.ppm = 2540 / (this.ppi * 100)\n        this.ppm = parseFloat(this.ppm.toFixed(10))\n\n        // Calculate scale ratio\n        this.scaleRatio = this.ppm / this.beamSize\n\n        // State...\n        this.gcode        = null\n        this.currentLine  = null\n        this.lastCommands = null\n\n        // Output size in millimeters\n        this.outputSize = { width : 0, height: 0 }\n\n        // G0 command\n        this.G1 = ['G', 1]\n        this.G0 = ['G', this.burnWhite ? 1 : 0]\n\n        // Calculate beam offset\n        this.beamOffset = this.beamSize * 1000 / 2000\n\n        // Calculate real beam range\n        this.realBeamRange = {\n            min: this.beamRange.max / 100 * this.beamPower.min,\n            max: this.beamRange.max / 100 * this.beamPower.max\n        }\n\n        // Adjuste feed rate to mm/min\n        if (this.feedUnit === 'mm/sec') {\n            this.feedRate *= 60\n        }\n\n        // register user callbacks\n        this.progress && this.on('progress', this.progress, this.progressContext)\n        this.done && this.on('done', this.done, this.doneContext)\n    }\n\n    // Process image\n    _processImage() {\n        // Call parent method\n        super._processImage()\n\n        // Calculate output size\n        this.outputSize = {\n            width : this.size.width  * (this.beamSize * 1000) / 1000,\n            height: this.size.height * (this.beamSize * 1000) / 1000\n        }\n    }\n\n    // Process image and return gcode string\n    run(progress, done) {\n        // Reset state\n        this.gcode        = []\n        this.lastCommands = {}\n        this.currentLine  = null\n\n        // register user callbacks\n        progress && this.on('progress', progress)\n        done && this.on('done', done)\n\n        // Add gcode header\n        this._addHeader()\n\n        // Scan type ?\n        if (this.diagonal) {\n            this._scanDiagonally()\n        }\n        else {\n            this._scanHorizontally()\n        }\n\n        if (! this.nonBlocking) {\n            return this.gcode\n        }\n    }\n\n    _addHeader() {\n        // Base headers\n        this.gcode.push(\n            '; Generated by LaserWeb (lw.raster-to-gcode.js)',\n            '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm',\n            '; Resolution : ' + this.ppm + ' PPM - ' + this.ppi + ' PPI',\n            '; Beam size  : ' + this.beamSize + ' mm',\n            '; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max,\n            '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %',\n            '; Feed rate  : ' + this.feedRate + ' mm/min'\n        )\n\n        // Print activated options\n        let options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal']\n\n        for (var i = options.length - 1; i >= 0; i--) {\n            if (! this[options[i]]) {\n                options.splice(i, 1)\n            }\n        }\n\n        if (options.length) {\n            this.gcode.push('; Options    : ' + options.join(', '))\n        }\n\n        // Set feed rates\n        this.gcode.push(\n            '',\n            'G0 F' + this.feedRate,\n            'G1 F' + this.feedRate,\n            ''\n        )\n    }\n\n    // Map S value to pixel power\n    _mapPixelPower(value) {\n        return value * (this.realBeamRange.max - this.realBeamRange.min)\n                     / 255 + this.realBeamRange.min\n    }\n\n    // Compute and return a command, return null if not changed\n    _command(name, value) {\n        // If the value argument is an object\n        if (typeof value === 'object') {\n            // Computed commands line\n            let commands = Array.prototype.slice.call(arguments)\n            let command, line = []\n\n            // for each command\n            for (var i = 0, il = commands.length; i < il; i++) {\n                command = this._command.apply(this, commands[i])\n                command && line.push(command)\n            }\n\n            // Return the line if not empty\n            return line.length ? line.join(' ') : null\n        }\n\n        // Format the value\n        value = value.toFixed(this.precision[name] || 0)\n\n        // If the value was changed or if verbose mode on\n        if (this.verboseG || value !== this.lastCommands[name]) {\n            this.lastCommands[name] = value\n            return name + value\n        }\n\n        // No change\n        return null\n    }\n\n    // Get a pixel power value from the canvas data grid\n    _getPixelPower(x, y, defaultValue) {\n        try {\n            // Reverse Y value since canvas as top/left origin\n            y = this.size.height - y - 1;\n\n            // Get pixel info\n            let pixel = this.getPixel(x, y)\n\n            // Reversed gray value [ 0 = white | 255 = black ]\n            return 255 - pixel.gray\n        }\n        catch (error) {\n            if (arguments.length === 3) {\n                return defaultValue\n            }\n            throw error\n        }\n    }\n\n    // Get a point from the current line with real world coordinates\n    _getPoint(index) {\n        // Get the point object from the current line\n        let point = this.currentLine[index]\n\n        // No point\n        if (! point) {\n            return null\n        }\n\n        // Commands\n        point.G = point.s ? ['G', 1] : this.G0\n        point.X = (point.x * this.beamSize) + this.offsets.X\n        point.Y = (point.y * this.beamSize) + this.offsets.Y\n        point.S = this._mapPixelPower(point.s)\n\n        // Offsets\n        if (this.diagonal) {\n            // Vertical offset\n            point.Y += this.beamSize\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n                point.Y -= this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n                point.Y += this.beamOffset\n            }\n        }\n        else {\n            // Vertical offset\n            point.Y += this.beamOffset\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n            }\n        }\n\n        // Return the point\n        return point\n    }\n\n    // Remove all trailing white spaces from the current line\n    _trimCurrentLine() {\n        // Remove white spaces from the left\n        let point = this.currentLine[0]\n\n        while (point && ! point.p) {\n            this.currentLine.shift()\n            point = this.currentLine[0]\n        }\n\n        // Remove white spaces from the right\n        point = this.currentLine[this.currentLine.length - 2]\n\n        while (point && ! point.p) {\n            this.currentLine.pop()\n            point = this.currentLine[this.currentLine.length - 2]\n        }\n\n        // Return the new line length\n        return this.currentLine.length\n    }\n\n    // Join pixel with same power\n    _reduceCurrentLine() {\n        // Line too short to be reduced\n        if (this.currentLine.length < 3) {\n            return this.currentLine.length\n        }\n\n        // Extract all points exept the first one\n        let points = this.currentLine.splice(1)\n\n        // Get current power\n        let power = this.currentLine[0].p\n\n        // For each extracted point\n        for (var point, i = 0, il = points.length - 1; i < il; i++) {\n            // Current point\n            point = points[i]\n\n            // On power change\n            if (power !== point.p) {\n                this.currentLine.push(point)\n            }\n\n            // Update power\n            power = point.p\n        }\n\n        // Add last point\n        this.currentLine.push(points[i])\n    }\n\n    // Add extra white pixels at the ends\n    _overscanCurrentLine(reversed) {\n        // Number of pixels to add on each side\n        let pixels = this.overscan / this.ppm\n\n        // Get first/last point\n        let firstPoint = this.currentLine[0]\n        let lastPoint  = this.currentLine[this.currentLine.length - 1]\n\n        // Is last white/colored point ?\n        firstPoint.s && (firstPoint.lastWhite  = true)\n        lastPoint.s  && (lastPoint.lastColored = true)\n\n        // Reversed line ?\n        reversed ? (lastPoint.s = 0) : (firstPoint.s = 0)\n\n        // Create left/right points\n        let rightPoint = { x: lastPoint.x + pixels , y: lastPoint.y , s: 0, p: 0 }\n        let leftPoint  = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 }\n\n        if (this.diagonal) {\n            leftPoint.y  += pixels\n            rightPoint.y -= pixels\n        }\n\n        // Add left/right points to current line\n        this.currentLine.unshift(leftPoint)\n        this.currentLine.push(rightPoint)\n    }\n\n    // Process current line and return an array of GCode text lines\n    _processCurrentLine(reversed) {\n        // Trim trailing white spaces ?\n        if (this.trimLine && ! this._trimCurrentLine()) {\n            // Skip empty line\n            return null\n        }\n\n        // Join pixel with same power\n        if (this.joinPixel) {\n            this._reduceCurrentLine()\n        }\n\n        // Overscan ?\n        if (this.overscan) {\n            this._overscanCurrentLine(reversed)\n        }\n\n        // Mark first and last point on the current line\n        this.currentLine[0].first = true\n        this.currentLine[this.currentLine.length - 1].last = true\n\n        // Reversed line ?\n        if (reversed) {\n            this.currentLine = this.currentLine.reverse()\n        }\n\n        // Point index\n        let point, index = 0\n\n        // Init loop vars...\n        let command, gcode = []\n\n        // Get first point\n        point = this._getPoint(index)\n\n        // Move to start of the line\n        command = this._command(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0])\n        command && gcode.push(command)\n\n        // For each point on the line\n        while (point) {\n            // Burn to next point\n            command = this._command(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S])\n            command && gcode.push(command)\n\n            // Get next point\n            point = this._getPoint(++index)\n        }\n\n        // Return gcode commands array\n        if (gcode.length) {\n            return gcode\n        }\n\n        // Empty line\n        return null\n    }\n\n    // Parse horizontally\n    _scanHorizontally() {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = () => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // For each pixel on the line\n            for (x = 0; x <= w; x++) {\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && ! point.p && p\n                lastColored = point && point.p && ! p\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add point to current line\n                this.currentLine.push(point)\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((y / h) * 100)\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            computeCurrentLine()\n            processCurrentLine()\n\n            y++\n\n            if (y < h) {\n                if (this.nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                this._onDone({ gcode: this.gcode })\n            }\n        }\n\n        processNextLine()\n\n        // // For each image line\n        // for (y = 0; y < h; y++) {\n        //     processNextLine()\n        // }\n    }\n\n    // Parse diagonally\n    _scanDiagonally() {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let totalLines  = w + h - 1\n        let lineNum     = 0\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = (x, y) => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // Increment line num\n            lineNum++\n\n            while(true) {\n                // Y limit reached !\n                if (y < -1 || y == h) {\n                    break\n                }\n\n                // X limit reached !\n                if (x < 0 || x > w) {\n                    break\n                }\n\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && (! point.p && p)\n                lastColored = point && (point.p && ! p)\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add the new point\n                this.currentLine.push(point)\n\n                // Next coords\n                x++\n                y--\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((lineNum / totalLines) * 100)\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            computeCurrentLine(x, y)\n            processCurrentLine()\n\n            if (! x) y++\n            else x++\n\n            if (y === h) {\n                x++\n                y--\n            }\n\n            if (y < h && x < w) {\n                if (this.nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                this._onDone({ gcode: this.gcode })\n            }\n        }\n\n        processNextLine()\n\n        // // For each image line\n        // for (y = 0; y < h; y++) {\n        //     scanDiagonalLine(x, y)\n        // }\n        //\n        // // For each image column (exept the first one)\n        // for (x = 1, y--; x < w; x++) {\n        //     scanDiagonalLine(x, y)\n        // }\n    }\n\n    _onProgress(event) {\n        //console.log('progress:', event.percent);\n    }\n\n    _onDone(event) {\n        //console.log('done:', event.gcode.length);\n    }\n\n    on(event, callback, context) {\n        let method = '_on' + event[0].toUpperCase() + event.slice(1)\n\n        if (! this[method] || typeof this[method] !== 'function') {\n            throw new Error('Undefined event: ' + event)\n        }\n\n        this[method] = event => callback.call(context || this, event)\n\n        return this\n    }\n}\n\n// Exports\nexport { RasterToGcode }\nexport default RasterToGcode\n\n\n\n// WEBPACK FOOTER //\n// ./raster-to-gcode.js","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"CanvasGrid\",[],t):\"object\"==typeof exports?exports.CanvasGrid=t():e.CanvasGrid=t()}(this,function(){return function(e){function t(a){if(i[a])return i[a].exports;var n=i[a]={exports:{},id:a,loaded:!1};return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports}var i={};return t.m=e,t.c=i,t.p=\"\",t(0)}([function(e,t,i){e.exports=i(1)},function(e,t,i){\"use strict\";function a(e){return e&&e.__esModule?e:{default:e}}function n(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(t,\"__esModule\",{value:!0}),t.CanvasGrid=void 0;var o=function(){function e(e,t){for(var i=0;i<t.length;i++){var a=t[i];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(t,i,a){return i&&e(t.prototype,i),a&&e(t,a),t}}(),r=i(2),s=a(r),l=function(){function e(t){n(this,e),this.cellSize=1024,this.scaleRatio=1,this.filters={},Object.assign(this,t||{}),this.size={width:0,height:0,cols:0,rows:0},this.file=null,this.image=null,this.url=null,this.canvas=[],this.pixels=[]}return o(e,[{key:\"load\",value:function(e){return e instanceof File?this.loadFromFile(e):e instanceof Image?this.loadFromImage(e):\"string\"==typeof e||e instanceof URL?this.loadFromURL(e.trim()):Promise.reject(new Error(\"Unsupported input format.\"))}},{key:\"_loadImage\",value:function(e,t,i){var a=this,n=new Image;n.onload=function(e){a.loadFromImage(n).then(function(e){a._processImage(),i(e)}).catch(t)},n.onerror=function(i){t(new Error(\"Error reading file : \"+e))},n.src=e}},{key:\"loadFromFile\",value:function(e){var t=this;return new Promise(function(i,a){e instanceof File||a(new Error(\"Input param must be a File object.\")),t.file=e,t._loadImage(URL.createObjectURL(e),a,i)})}},{key:\"loadFromURL\",value:function(e){var t=this;return new Promise(function(i,a){e instanceof URL||\"string\"==typeof e||a(new Error(\"Input param must be a URL string or object.\"));var n=e instanceof URL?e:new URL(e);t.url=n,t._loadImage(n,a,i)})}},{key:\"loadFromImage\",value:function(e){var t=this;return new Promise(function(i,a){e instanceof Image||a(new Error(\"Input param must be a Image object.\")),t.image=e,i(t)})}},{key:\"_processImage\",value:function(){this.canvas=[],this.pixels=[];var e=Math.round(this.image.width*this.scaleRatio),t=Math.round(this.image.height*this.scaleRatio),i=Math.ceil(e/this.cellSize),a=Math.ceil(t/this.cellSize);this.size={width:e,height:t,cols:i,rows:a};var n=null,o=null,r=null,l=null,h=null,c=null,u=null,d=null,m=null;for(h=0;h<this.size.rows;h++){for(n=[],l=0;l<this.size.cols;l++)o=document.createElement(\"canvas\"),0===l||l<this.size.cols-1?o.width=this.size.width<this.cellSize?this.size.width:this.cellSize:o.width=this.size.width%this.cellSize,0===h||h<this.size.rows-1?o.height=this.size.height<this.cellSize?this.size.height:this.cellSize:o.height=this.size.height%this.cellSize,r=o.getContext(\"2d\"),r.fillStyle=\"white\",r.fillRect(0,0,o.width,o.height),d=o.width/this.scaleRatio,m=o.height/this.scaleRatio,c=l*this.cellSize/this.scaleRatio,u=h*this.cellSize/this.scaleRatio,r.drawImage(this.image,c,u,d,m,0,0,o.width,o.height),(0,s.default)(o,this.filters),n.push(o);this.canvas.push(n)}}},{key:\"getPixel\",value:function(e,t){if(e=parseInt(e),t=parseInt(t),isNaN(e)||isNaN(t))throw new Error(\"[x, y] params must be Integer.\");if(e<0||e>=this.size.width)throw new Error(\"Out of range: x = \"+e+\", max: \"+this.size.width);if(t<0||t>=this.size.height)throw new Error(\"Out of range: y = \"+t+\", max: \"+this.size.height);var i=parseInt(e/this.cellSize),a=parseInt(t/this.cellSize);i&&(e-=this.cellSize*i),a&&(t-=this.cellSize*a);var n=this.canvas[a][i],o=n.getContext(\"2d\"),r=o.getImageData(e,t,1,1).data;return{color:{r:r[0],g:r[1],b:r[2],a:r[3]},gray:(r[0]+r[1]+r[2])/3,grid:{col:i,row:a},coords:{x:e,y:t}}}}]),e}();t.CanvasGrid=l,t.default=l},function(e,t,i){!function(t,i){e.exports=i()}(this,function(){return function(e){function t(a){if(i[a])return i[a].exports;var n=i[a]={exports:{},id:a,loaded:!1};return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports}var i={};return t.m=e,t.c=i,t.p=\"\",t(0)}([function(e,t,i){e.exports=i(1)},function(e,t){\"use strict\";function i(e){return e<0?0:e>255?255:e}function a(e,t,a){void 0!==a&&(e[t]=i(e[t]+a),e[t+1]=i(e[t+1]+a),e[t+2]=i(e[t+2]+a))}function n(e,t,a){void 0!==a&&(e[t]=i(a*(e[t]-128)+128),e[t+1]=i(a*(e[t+1]-128)+128),e[t+2]=i(a*(e[t+2]-128)+128))}function o(e,t,a){void 0!==a&&(e[t]=i(Math.exp(Math.log(255*(e[t]/255))*a)),e[t+1]=i(Math.exp(Math.log(255*(e[t+1]/255))*a)),e[t+2]=i(Math.exp(Math.log(255*(e[t+2]/255))*a)))}function r(e,t,a,n){if(l.indexOf(a)===-1)throw new Error(\"Unsupported grayscale algorithm: \"+a);if(\"none\"===a)return null;var o=void 0,r=e[t],s=e[t+1],h=e[t+2];switch(a){case\"average\":o=(r+s+h)/3;break;case\"luma\":o=.3*r+.59*s+.11*h;break;case\"luma-601\":o=.299*r+.587*s+.114*h;break;case\"luma-709\":o=.2126*r+.7152*s+.0722*h;break;case\"luma-240\":o=.212*r+.701*s+.087*h;break;case\"desaturation\":o=(Math.max(r,s,h)+Math.min(r,s,h))/2;break;case\"decomposition-min\":o=Math.min(r,s,h);break;case\"decomposition-max\":o=Math.max(r,s,h);break;case\"red-chanel\":o=r;break;case\"green-chanel\":o=s;break;case\"blue-chanel\":o=h}void 0!==n&&(o=parseInt(o/n)*n),o=parseInt(o),e[t]=i(o),e[t+1]=i(o),e[t+2]=i(o)}function s(e,t){t=Object.assign({},{smoothing:!1,brightness:0,contrast:0,gamma:0,grayscale:\"none\",shadesOfGray:256},t||{});var i=e.getContext(\"2d\");void 0!==i.imageSmoothingEnabled?i.imageSmoothingEnabled=t.smoothing:(i.mozImageSmoothingEnabled=t.smoothing,i.webkitImageSmoothingEnabled=t.smoothing,i.msImageSmoothingEnabled=t.smoothing,i.oImageSmoothingEnabled=t.smoothing);var s=i.getImageData(0,0,e.width,e.height),l=s.data,h=void 0,c=void 0,u=void 0,d=void 0;0!==t.contrast&&(h=259*(t.contrast+255)/(255*(259-t.contrast))),0!==t.brightness&&(c=t.brightness),0!==t.gamma&&(u=1/t.gamma),t.shadesOfGray>1&&t.shadesOfGray<256&&(d=255/(t.shadesOfGray-1));for(var m=0,f=l.length;m<f;m+=4)a(l,m,c),n(l,m,h),o(l,m,u),r(l,m,t.grayscale,d);i.putImageData(s,0,0)}Object.defineProperty(t,\"__esModule\",{value:!0});var l=[\"none\",\"average\",\"desaturation\",\"decomposition-min\",\"decomposition-max\",\"luma\",\"luma-601\",\"luma-709\",\"luma-240\",\"red-chanel\",\"green-chanel\",\"blue-chanel\"];t.canvasFilters=s,t.default=s}])})}])});\n//# sourceMappingURL=lw.canvas-grid.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.canvas-grid/dist/lw.canvas-grid.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}