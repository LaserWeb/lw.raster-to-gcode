{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.raster-to-gcode.min.js","webpack:///webpack/bootstrap 6d3497b34e19e094fdac","webpack:///./raster-to-gcode.js","webpack:///../~/lw.canvas-grid/dist/lw.canvas-grid.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","RasterToGcode","undefined","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_lw","_lw2","_CanvasGrid","settings","assign","ppi","x","y","toolDiameter","rapidRate","feedRate","rateUnit","beamRange","min","max","beamPower","milling","zSafe","zSurface","zDepth","offsets","X","Y","trimLine","joinPixel","burnWhite","verboseG","diagonal","overscan","precision","S","nonBlocking","filters","smoothing","brightness","contrast","gamma","grayscale","shadesOfGray","invertColor","progress","progressContext","done","doneContext","_this","Error","ppm","parseFloat","toFixed","scaleRatio","gcode","currentLine","lastCommands","outputSize","width","height","G1","G0","beamOffset","realBeamRange","on","size","_addHeader","_scanDiagonally","_scanHorizontally","push","options","splice","join","range","name","commands","Array","slice","arguments","command","line","il","_command","apply","defaultValue","pixel","getPixel","gray","error","index","point","G","s","_mapPixelPower","first","lastWhite","last","lastColored","shift","pop","points","power","reversed","pixels","firstPoint","lastPoint","rightPoint","leftPoint","unshift","_this2","_trimCurrentLine","_reduceCurrentLine","_overscanCurrentLine","reverse","addCommand","_getPoint","plung","_this3","w","h","computeCurrentLine","_getPixelPower","percent","lastPercent","processCurrentLine","_processCurrentLine","Math","round","_onProgress","processNextLine","setTimeout","_onDone","_this4","totalLines","lineNum","event","callback","context","_this5","method","toUpperCase","_this6","heightMap","onProgress","onDone","CanvasGrid","cellSize","cols","rows","file","image","url","canvas","input","File","loadFromFile","Image","loadFromImage","URL","loadFromURL","trim","Promise","reject","src","resolve","onload","then","catch","onerror","_loadImage","createObjectURL","_processImage","ceil","sx","sy","sw","sh","document","createElement","getContext","fillStyle","fillRect","drawImage","parseInt","isNaN","col","row","pixelData","getImageData","data","color","r","g","b","a","grid","coords","exp","log","algorithm","shades","grayscaleAlgorithms","indexOf","canvasFilters","imageSmoothingEnabled","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","oImageSmoothingEnabled","imageData","contrastFactor","brightnessOffset","gammaCorrection","shadesOfGrayFactor","putImageData"],"mappings":"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","file":"lw.raster-to-gcode.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"RasterToGcode\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RasterToGcode\"] = factory();\n\telse\n\t\troot[\"RasterToGcode\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"RasterToGcode\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RasterToGcode\"] = factory();\n\telse\n\t\troot[\"RasterToGcode\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.RasterToGcode = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _lw = __webpack_require__(2);\n\t\n\tvar _lw2 = _interopRequireDefault(_lw);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// RasterToGcode class\n\tvar RasterToGcode = function (_CanvasGrid) {\n\t    _inherits(RasterToGcode, _CanvasGrid);\n\t\n\t    // Class constructor...\n\t    function RasterToGcode(settings) {\n\t        _classCallCheck(this, RasterToGcode);\n\t\n\t        // Defaults settings\n\t        settings = Object.assign({\n\t            ppi: { x: 254, y: 254 }, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\t\n\t            toolDiameter: 0.1, // Tool diameter in millimeters\n\t            rapidRate: 1500, // Feed rate in mm/min (G0 F value)\n\t            feedRate: 500, // Feed rate in mm/min (G1 F value)\n\t            rateUnit: 'mm/min', // Feed rate unit [mm/min, mm/sec]\n\t\n\t            beamRange: { min: 0, max: 1 }, // Beam power range (Firmware value)\n\t            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n\t\n\t            milling: false, // EXPERIMENTAL\n\t            zSafe: 5, // Safe Z for fast move\n\t            zSurface: 0, // Usinable surface\n\t            zDepth: -10, // Z depth (min:white, max:black)\n\t\n\t            offsets: { X: 0, Y: 0 }, // Global coordinates offsets\n\t            trimLine: true, // Trim trailing white pixels\n\t            joinPixel: true, // Join consecutive pixels with same intensity\n\t            burnWhite: true, // [true = G1 S0 | false = G0] on inner white pixels\n\t            verboseG: false, // Output verbose GCode (print each commands)\n\t            diagonal: false, // Go diagonally (increase the distance between points)\n\t            overscan: 0, // Add some extra white space (in millimeters) before and after each line\n\t\n\t            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\t\n\t            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\t\n\t            filters: {\n\t                smoothing: 0, // Smoothing the input image ?\n\t                brightness: 0, // Image brightness [-255 to +255]\n\t                contrast: 0, // Image contrast [-255 to +255]\n\t                gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t                grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t                shadesOfGray: 256, // Number of shades of gray [2-256]\n\t                invertColor: false // Invert color...\n\t            },\n\t\n\t            progress: null, // On progress callbacks\n\t            progressContext: null, // On progress callback context\n\t\n\t            done: null, // On done callback\n\t            doneContext: null // On done callback context\n\t        }, settings || {});\n\t\n\t        // Init properties\n\t\n\t        // Milling settings\n\t        var _this = _possibleConstructorReturn(this, (RasterToGcode.__proto__ || Object.getPrototypeOf(RasterToGcode)).call(this, settings));\n\t\n\t        if (_this.milling) {\n\t            if (_this.zSafe < _this.zSurface) {\n\t                throw new Error('\"zSafe\" must be greater to \"zSurface\"');\n\t            }\n\t        }\n\t\n\t        // Negative beam size ?\n\t        if (_this.toolDiameter <= 0) {\n\t            throw new Error('\"toolDiameter\" must be positive');\n\t        }\n\t\n\t        // Uniforme ppi\n\t        if (!_this.ppi.x) {\n\t            _this.ppi = { x: _this.ppi, y: _this.ppi };\n\t        }\n\t\n\t        // Calculate PPM = Pixel Per Millimeters\n\t        // this.ppm = 2540 / (this.ppi * 100)\n\t        // this.ppm = parseFloat(this.ppm.toFixed(10))\n\t        _this.ppm = {\n\t            x: parseFloat((2540 / (_this.ppi.x * 100)).toFixed(10)),\n\t            y: parseFloat((2540 / (_this.ppi.y * 100)).toFixed(10))\n\t        };\n\t\n\t        // Calculate scale ratio\n\t        _this.scaleRatio = {\n\t            x: _this.ppm.x / _this.toolDiameter,\n\t            y: _this.ppm.y / _this.toolDiameter\n\t        };\n\t\n\t        // State...\n\t        _this.gcode = null;\n\t        _this.currentLine = null;\n\t        _this.lastCommands = null;\n\t\n\t        // Output size in millimeters\n\t        _this.outputSize = { width: 0, height: 0 };\n\t\n\t        // G0 command\n\t        _this.G1 = ['G', 1];\n\t        _this.G0 = ['G', _this.burnWhite ? 1 : 0];\n\t\n\t        // Calculate beam offset\n\t        _this.beamOffset = _this.toolDiameter * 1000 / 2000;\n\t\n\t        // Calculate real beam range\n\t        _this.realBeamRange = {\n\t            min: _this.beamRange.max / 100 * _this.beamPower.min,\n\t            max: _this.beamRange.max / 100 * _this.beamPower.max\n\t        };\n\t\n\t        // Adjuste feed rate to mm/min\n\t        if (_this.rateUnit === 'mm/sec') {\n\t            _this.feedRate *= 60;\n\t            _this.rapidRate *= 60;\n\t        }\n\t\n\t        // register user callbacks\n\t        _this.progress && _this.on('progress', _this.progress, _this.progressContext);\n\t        _this.done && _this.on('done', _this.done, _this.doneContext);\n\t        return _this;\n\t    }\n\t\n\t    // Process image\n\t\n\t\n\t    _createClass(RasterToGcode, [{\n\t        key: '_processImage',\n\t        value: function _processImage() {\n\t            // Call parent method\n\t            _get(RasterToGcode.prototype.__proto__ || Object.getPrototypeOf(RasterToGcode.prototype), '_processImage', this).call(this);\n\t\n\t            // Calculate output size\n\t            this.outputSize = {\n\t                width: this.size.width * (this.toolDiameter * 1000) / 1000,\n\t                height: this.size.height * (this.toolDiameter * 1000) / 1000\n\t            };\n\t        }\n\t\n\t        // Process image and return gcode string\n\t\n\t    }, {\n\t        key: 'run',\n\t        value: function run(settings) {\n\t            // Reset state\n\t            this.gcode = [];\n\t            this.lastCommands = {};\n\t            this.currentLine = null;\n\t\n\t            // Defaults settings\n\t            settings = settings || {};\n\t\n\t            // register user callbacks\n\t            settings.progress && this.on('progress', settings.progress, settings.progressContext);\n\t            settings.done && this.on('done', settings.done, settings.doneContext);\n\t\n\t            var nonBlocking = this.nonBlocking;\n\t\n\t            if (settings.nonBlocking !== undefined) {\n\t                nonBlocking = settings.nonBlocking;\n\t            }\n\t\n\t            // Add gcode header\n\t            this._addHeader();\n\t\n\t            // Scan type ?\n\t            if (this.diagonal) {\n\t                this._scanDiagonally(nonBlocking);\n\t            } else {\n\t                this._scanHorizontally(nonBlocking);\n\t            }\n\t\n\t            if (!nonBlocking) {\n\t                return this.gcode;\n\t            }\n\t        }\n\t    }, {\n\t        key: '_addHeader',\n\t        value: function _addHeader() {\n\t            // Base headers\n\t            this.gcode.push('; Generated by LaserWeb (lw.raster-to-gcode.js)', '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm', '; PPI        : x: ' + this.ppi.x + ' - y: ' + this.ppi.y, '; PPM        : x: ' + this.ppm.x + ' - y: ' + this.ppm.y, '; Tool diam. : ' + this.toolDiameter + ' mm', '; Rapid rate : ' + this.rapidRate + ' ' + this.rateUnit, '; Feed rate  : ' + this.feedRate + ' ' + this.rateUnit);\n\t\n\t            if (this.milling) {\n\t                this.gcode.push('; Z safe     : ' + this.zSafe, '; Z surface  : ' + this.zSurface, '; Z depth    : ' + this.zDepth);\n\t            } else {\n\t                this.gcode.push('; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max, '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %');\n\t            }\n\t\n\t            // Print activated options\n\t            var options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal'];\n\t\n\t            for (var i = options.length - 1; i >= 0; i--) {\n\t                if (!this[options[i]]) {\n\t                    options.splice(i, 1);\n\t                }\n\t            }\n\t\n\t            if (options.length) {\n\t                this.gcode.push('; Options    : ' + options.join(', '));\n\t            }\n\t\n\t            // Set feed rates\n\t            this.gcode.push('', 'G0 F' + this.rapidRate, 'G1 F' + this.feedRate, '');\n\t        }\n\t\n\t        // Map S value to pixel power\n\t\n\t    }, {\n\t        key: '_mapPixelPower',\n\t        value: function _mapPixelPower(value) {\n\t            var range = this.milling ? { min: 0, max: this.zDepth } : this.realBeamRange;\n\t            return value * (range.max - range.min) / 255 + range.min;\n\t        }\n\t\n\t        // Compute and return a command, return null if not changed\n\t\n\t    }, {\n\t        key: '_command',\n\t        value: function _command(name, value) {\n\t            // If the value argument is an object\n\t            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n\t                // Computed commands line\n\t                var commands = Array.prototype.slice.call(arguments);\n\t                var command = void 0,\n\t                    line = [];\n\t\n\t                // for each command\n\t                for (var i = 0, il = commands.length; i < il; i++) {\n\t                    command = this._command.apply(this, commands[i]);\n\t                    command && line.push(command);\n\t                }\n\t\n\t                // Return the line if not empty\n\t                return line.length ? line.join(' ') : null;\n\t            }\n\t\n\t            // Format the value\n\t            value = value.toFixed(this.precision[name] || 0);\n\t\n\t            // If the value was changed or if verbose mode on\n\t            if (this.verboseG || value !== this.lastCommands[name]) {\n\t                this.lastCommands[name] = value;\n\t                return name + value;\n\t            }\n\t\n\t            // No change\n\t            return null;\n\t        }\n\t\n\t        // Get a pixel power value from the canvas data grid\n\t\n\t    }, {\n\t        key: '_getPixelPower',\n\t        value: function _getPixelPower(x, y, defaultValue) {\n\t            try {\n\t                // Reverse Y value since canvas as top/left origin\n\t                y = this.size.height - y - 1;\n\t\n\t                // Get pixel info\n\t                var pixel = this.getPixel(x, y);\n\t\n\t                // Reversed gray value [ 0 = white | 255 = black ]\n\t                return 255 - pixel.gray;\n\t            } catch (error) {\n\t                if (arguments.length === 3) {\n\t                    return defaultValue;\n\t                }\n\t                throw error;\n\t            }\n\t        }\n\t\n\t        // Get a point from the current line with real world coordinates\n\t\n\t    }, {\n\t        key: '_getPoint',\n\t        value: function _getPoint(index) {\n\t            // Get the point object from the current line\n\t            var point = this.currentLine[index];\n\t\n\t            // No point\n\t            if (!point) {\n\t                return null;\n\t            }\n\t\n\t            // Commands\n\t            point.G = point.s ? ['G', 1] : this.G0;\n\t            point.X = point.x * this.toolDiameter + this.offsets.X;\n\t            point.Y = point.y * this.toolDiameter + this.offsets.Y;\n\t            point.S = this._mapPixelPower(point.s);\n\t\n\t            // Offsets\n\t            if (this.diagonal) {\n\t                // Vertical offset\n\t                point.Y += this.toolDiameter;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                    point.Y -= this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                    point.Y += this.beamOffset;\n\t                }\n\t            } else {\n\t                // Vertical offset\n\t                point.Y += this.beamOffset;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                }\n\t            }\n\t\n\t            // Return the point\n\t            return point;\n\t        }\n\t\n\t        // Remove all trailing white spaces from the current line\n\t\n\t    }, {\n\t        key: '_trimCurrentLine',\n\t        value: function _trimCurrentLine() {\n\t            // Remove white spaces from the left\n\t            var point = this.currentLine[0];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.shift();\n\t                point = this.currentLine[0];\n\t            }\n\t\n\t            // Remove white spaces from the right\n\t            point = this.currentLine[this.currentLine.length - 2];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.pop();\n\t                point = this.currentLine[this.currentLine.length - 2];\n\t            }\n\t\n\t            // Return the new line length\n\t            return this.currentLine.length;\n\t        }\n\t\n\t        // Join pixel with same power\n\t\n\t    }, {\n\t        key: '_reduceCurrentLine',\n\t        value: function _reduceCurrentLine() {\n\t            // Line too short to be reduced\n\t            if (this.currentLine.length < 3) {\n\t                return this.currentLine.length;\n\t            }\n\t\n\t            // Extract all points exept the first one\n\t            var points = this.currentLine.splice(1);\n\t\n\t            // Get current power\n\t            var power = this.currentLine[0].p;\n\t\n\t            // For each extracted point\n\t            for (var point, i = 0, il = points.length - 1; i < il; i++) {\n\t                // Current point\n\t                point = points[i];\n\t\n\t                // On power change\n\t                if (power !== point.p) {\n\t                    this.currentLine.push(point);\n\t                }\n\t\n\t                // Update power\n\t                power = point.p;\n\t            }\n\t\n\t            // Add last point\n\t            this.currentLine.push(points[i]);\n\t        }\n\t\n\t        // Add extra white pixels at the ends\n\t\n\t    }, {\n\t        key: '_overscanCurrentLine',\n\t        value: function _overscanCurrentLine(reversed) {\n\t            // Number of pixels to add on each side\n\t            var pixels = this.overscan / this.ppm.x;\n\t\n\t            // Get first/last point\n\t            var firstPoint = this.currentLine[0];\n\t            var lastPoint = this.currentLine[this.currentLine.length - 1];\n\t\n\t            // Is last white/colored point ?\n\t            firstPoint.s && (firstPoint.lastWhite = true);\n\t            lastPoint.s && (lastPoint.lastColored = true);\n\t\n\t            // Reversed line ?\n\t            reversed ? lastPoint.s = 0 : firstPoint.s = 0;\n\t\n\t            // Create left/right points\n\t            var rightPoint = { x: lastPoint.x + pixels, y: lastPoint.y, s: 0, p: 0 };\n\t            var leftPoint = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 };\n\t\n\t            if (this.diagonal) {\n\t                leftPoint.y += pixels;\n\t                rightPoint.y -= pixels;\n\t            }\n\t\n\t            // Add left/right points to current line\n\t            this.currentLine.unshift(leftPoint);\n\t            this.currentLine.push(rightPoint);\n\t        }\n\t\n\t        // Process current line and return an array of GCode text lines\n\t\n\t    }, {\n\t        key: '_processCurrentLine',\n\t        value: function _processCurrentLine(reversed) {\n\t            var _this2 = this;\n\t\n\t            // Trim trailing white spaces ?\n\t            if ((this.milling || this.trimLine) && !this._trimCurrentLine()) {\n\t                // Skip empty line\n\t                return null;\n\t            }\n\t\n\t            // Join pixel with same power\n\t            if (this.joinPixel) {\n\t                this._reduceCurrentLine();\n\t            }\n\t\n\t            // Overscan ?\n\t            if (this.overscan) {\n\t                this._overscanCurrentLine(reversed);\n\t            }\n\t\n\t            // Mark first and last point on the current line\n\t            this.currentLine[0].first = true;\n\t            this.currentLine[this.currentLine.length - 1].last = true;\n\t\n\t            // Reversed line ?\n\t            if (reversed) {\n\t                this.currentLine = this.currentLine.reverse();\n\t            }\n\t\n\t            // Point index\n\t            var point = void 0,\n\t                index = 0;\n\t\n\t            // Init loop vars...\n\t            var command = void 0,\n\t                gcode = [];\n\t\n\t            var addCommand = function addCommand() {\n\t                command = _this2._command.apply(_this2, arguments);\n\t                command && gcode.push(command);\n\t            };\n\t\n\t            // Get first point\n\t            point = this._getPoint(index);\n\t\n\t            // Action\n\t            if (this.milling) {\n\t                var plung = false;\n\t                var lastPoint = null;\n\t\n\t                // Move to start of the line\n\t                addCommand(['G', 0], ['Z', this.zSafe]);\n\t                addCommand(['G', 0], ['X', point.X], ['Y', point.Y]);\n\t                addCommand(['G', 0], ['Z', this.zSurface]);\n\t\n\t                // For each point on the line\n\t                while (point) {\n\t                    if (point.S) {\n\t                        if (plung) {\n\t                            addCommand(['G', 0], ['Z', this.zSurface]);\n\t                            plung = false;\n\t                        }\n\t\n\t                        addCommand(['G', 1], ['Z', this.zSurface + point.S]);\n\t                        addCommand(['G', 1], ['X', point.X], ['Y', point.Y]);\n\t                    } else {\n\t                        if (plung) {\n\t                            addCommand(['G', 1], ['Z', this.zSurface]);\n\t                            plung = false;\n\t                        }\n\t\n\t                        addCommand(['G', 0], ['Z', this.zSafe]);\n\t                        addCommand(['G', 0], ['X', point.X], ['Y', point.Y]);\n\t                    }\n\t\n\t                    if (point.lastWhite || point.lastColored) {\n\t                        plung = true;\n\t                    }\n\t\n\t                    // Get next point\n\t                    lastPoint = point;\n\t                    point = this._getPoint(++index);\n\t                }\n\t\n\t                // Move to Z safe\n\t                addCommand(['G', 1], ['Z', this.zSurface]);\n\t                addCommand(['G', 0], ['Z', this.zSafe]);\n\t            } else {\n\t                // Move to start of the line\n\t                addCommand(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0]);\n\t\n\t                // For each point on the line\n\t                while (point) {\n\t                    // Burn to next point\n\t                    addCommand(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S]);\n\t\n\t                    // Get next point\n\t                    point = this._getPoint(++index);\n\t                }\n\t            }\n\t\n\t            // Return gcode commands array\n\t            if (gcode.length) {\n\t                return gcode;\n\t            }\n\t\n\t            // Empty line\n\t            return null;\n\t        }\n\t\n\t        // Parse horizontally\n\t\n\t    }, {\n\t        key: '_scanHorizontally',\n\t        value: function _scanHorizontally(nonBlocking) {\n\t            var _this3 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine() {\n\t                // Reset current line\n\t                _this3.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // For each pixel on the line\n\t                for (x = 0; x <= w; x++) {\n\t                    // Get pixel power\n\t                    s = p = _this3._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add point to current line\n\t                    _this3.currentLine.push(point);\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this3._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(y / h * 100);\n\t                if (percent > lastPercent) {\n\t                    _this3._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this3.gcode.push.apply(_this3.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                computeCurrentLine();\n\t                processCurrentLine();\n\t\n\t                y++;\n\t\n\t                if (y < h) {\n\t                    if (nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    _this3._onDone({ gcode: _this3.gcode });\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t\n\t            // // For each image line\n\t            // for (y = 0; y < h; y++) {\n\t            //     processNextLine()\n\t            // }\n\t        }\n\t\n\t        // Parse diagonally\n\t\n\t    }, {\n\t        key: '_scanDiagonally',\n\t        value: function _scanDiagonally(nonBlocking) {\n\t            var _this4 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var totalLines = w + h - 1;\n\t            var lineNum = 0;\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine(x, y) {\n\t                // Reset current line\n\t                _this4.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // Increment line num\n\t                lineNum++;\n\t\n\t                while (true) {\n\t                    // Y limit reached !\n\t                    if (y < -1 || y == h) {\n\t                        break;\n\t                    }\n\t\n\t                    // X limit reached !\n\t                    if (x < 0 || x > w) {\n\t                        break;\n\t                    }\n\t\n\t                    // Get pixel power\n\t                    s = p = _this4._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add the new point\n\t                    _this4.currentLine.push(point);\n\t\n\t                    // Next coords\n\t                    x++;\n\t                    y--;\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this4._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(lineNum / totalLines * 100);\n\t                if (percent > lastPercent) {\n\t                    _this4._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this4.gcode.push.apply(_this4.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                computeCurrentLine(x, y);\n\t                processCurrentLine();\n\t\n\t                if (!x) y++;else x++;\n\t\n\t                if (y === h) {\n\t                    x++;\n\t                    y--;\n\t                }\n\t\n\t                if (y < h && x < w) {\n\t                    if (nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    _this4._onDone({ gcode: _this4.gcode });\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t\n\t            // // For each image line\n\t            // for (y = 0; y < h; y++) {\n\t            //     scanDiagonalLine(x, y)\n\t            // }\n\t            //\n\t            // // For each image column (exept the first one)\n\t            // for (x = 1, y--; x < w; x++) {\n\t            //     scanDiagonalLine(x, y)\n\t            // }\n\t        }\n\t    }, {\n\t        key: '_onProgress',\n\t        value: function _onProgress(event) {\n\t            //console.log('progress:', event.percent);\n\t        }\n\t    }, {\n\t        key: '_onDone',\n\t        value: function _onDone(event) {\n\t            //console.log('done:', event.gcode.length);\n\t        }\n\t    }, {\n\t        key: 'on',\n\t        value: function on(event, callback, context) {\n\t            var _this5 = this;\n\t\n\t            var method = '_on' + event[0].toUpperCase() + event.slice(1);\n\t\n\t            if (!this[method] || typeof this[method] !== 'function') {\n\t                throw new Error('Undefined event: ' + event);\n\t            }\n\t\n\t            this[method] = function (event) {\n\t                return callback.call(context || _this5, event);\n\t            };\n\t\n\t            return this;\n\t        }\n\t\n\t        // Return the bitmap height-map\n\t\n\t    }, {\n\t        key: 'getHeightMap',\n\t        value: function getHeightMap(settings) {\n\t            var _this6 = this;\n\t\n\t            // Init loop vars{\n\t            var heightMap = [];\n\t            var x = 0;\n\t            var y = 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            // Defaults settings\n\t            settings = settings || {};\n\t\n\t            // register user callbacks\n\t            var onProgress = settings.progress || function () {};\n\t            var onDone = settings.done || function () {};\n\t\n\t            // Non blocking mode ?\n\t            var nonBlocking = this.nonBlocking;\n\t\n\t            if (settings.nonBlocking !== undefined) {\n\t                nonBlocking = settings.nonBlocking;\n\t            }\n\t\n\t            var computeCurrentLine = function computeCurrentLine() {\n\t                // Reset current line\n\t                var pixels = [];\n\t\n\t                // For each pixel on the line\n\t                for (x = 0; x < w; x++) {\n\t                    pixels.push(_this6._mapPixelPower(_this6._getPixelPower(x, y)));\n\t                }\n\t\n\t                // Call progress callback\n\t                percent = Math.round(y / h * 100);\n\t\n\t                if (percent > lastPercent) {\n\t                    onProgress.call(settings.progressContext || _this6, { pixels: pixels, percent: percent });\n\t                }\n\t\n\t                lastPercent = percent;\n\t\n\t                // Add pixels line\n\t                heightMap.push(pixels);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                computeCurrentLine();\n\t\n\t                y++;\n\t\n\t                if (y < h) {\n\t                    if (nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    onDone.call(settings.doneContext || _this6, { heightMap: heightMap });\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t\n\t            if (!nonBlocking) {\n\t                return heightMap;\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return RasterToGcode;\n\t}(_lw2.default);\n\t\n\t// Exports\n\t\n\t\n\texports.RasterToGcode = RasterToGcode;\n\texports.default = RasterToGcode;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(\"CanvasGrid\", [], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"CanvasGrid\"] = factory();\n\t\telse\n\t\t\troot[\"CanvasGrid\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t    value: true\n\t\t});\n\t\texports.CanvasGrid = undefined;\n\t\t\n\t\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\t\n\t\tvar _lw = __webpack_require__(2);\n\t\t\n\t\tvar _lw2 = _interopRequireDefault(_lw);\n\t\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\t\n\t\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\t\n\t\t// CanvasGrid class\n\t\tvar CanvasGrid = function () {\n\t\t    // Class constructor...\n\t\t    function CanvasGrid(settings) {\n\t\t        _classCallCheck(this, CanvasGrid);\n\t\t\n\t\t        // Init properties\n\t\t        this.cellSize = 1024;\n\t\t        this.scaleRatio = { x: 1, y: 1 };\n\t\t        this.filters = {};\n\t\t\n\t\t        Object.assign(this, settings || {});\n\t\t\n\t\t        if (!this.scaleRatio.x) {\n\t\t            this.scaleRatio = { x: this.scaleRatio, y: this.scaleRatio };\n\t\t        }\n\t\t\n\t\t        this.size = { width: 0, height: 0, cols: 0, rows: 0 };\n\t\t        this.file = null;\n\t\t        this.image = null;\n\t\t        this.url = null;\n\t\t        this.canvas = [];\n\t\t        this.pixels = [];\n\t\t    }\n\t\t\n\t\t    // <input> can be Image, File, URL object or URL string (http://* or data:image/*)\n\t\t\n\t\t\n\t\t    _createClass(CanvasGrid, [{\n\t\t        key: 'load',\n\t\t        value: function load(input) {\n\t\t            // Load File object\n\t\t            if (input instanceof File) {\n\t\t                return this.loadFromFile(input);\n\t\t            }\n\t\t\n\t\t            // Load Image object\n\t\t            if (input instanceof Image) {\n\t\t                return this.loadFromImage(input);\n\t\t            }\n\t\t\n\t\t            // Load URL object\n\t\t            if (typeof input === 'string' || input instanceof URL) {\n\t\t                return this.loadFromURL(input.trim());\n\t\t            }\n\t\t\n\t\t            // Return rejected promise with an Error object\n\t\t            return Promise.reject(new Error('Unsupported input format.'));\n\t\t        }\n\t\t\n\t\t        // Load image\n\t\t\n\t\t    }, {\n\t\t        key: '_loadImage',\n\t\t        value: function _loadImage(src, reject, resolve) {\n\t\t            var _this = this;\n\t\t\n\t\t            // Create Image object\n\t\t            var image = new Image();\n\t\t\n\t\t            // Register for load and error events\n\t\t            image.onload = function (event) {\n\t\t                _this.loadFromImage(image).then(resolve).catch(reject);\n\t\t            };\n\t\t\n\t\t            image.onerror = function (event) {\n\t\t                reject(new Error('An error occurred while loading the image : ' + src));\n\t\t            };\n\t\t\n\t\t            // Load the image from File url\n\t\t            image.src = src;\n\t\t        }\n\t\t\n\t\t        // Load from File object\n\t\t\n\t\t    }, {\n\t\t        key: 'loadFromFile',\n\t\t        value: function loadFromFile(input) {\n\t\t            var _this2 = this;\n\t\t\n\t\t            return new Promise(function (resolve, reject) {\n\t\t                // Bad input type\n\t\t                if (!(input instanceof File)) {\n\t\t                    reject(new Error('Input param must be a File object.'));\n\t\t                }\n\t\t\n\t\t                // Set input file\n\t\t                _this2.file = input;\n\t\t\n\t\t                // Load image\n\t\t                _this2._loadImage(URL.createObjectURL(input), reject, resolve);\n\t\t            });\n\t\t        }\n\t\t\n\t\t        // Load from URL object or string\n\t\t\n\t\t    }, {\n\t\t        key: 'loadFromURL',\n\t\t        value: function loadFromURL(input) {\n\t\t            var _this3 = this;\n\t\t\n\t\t            return new Promise(function (resolve, reject) {\n\t\t                // Bad input type\n\t\t                if (!(input instanceof URL) && typeof input !== 'string') {\n\t\t                    reject(new Error('Input param must be a URL string or object.'));\n\t\t                }\n\t\t\n\t\t                // Create url object\n\t\t                var url = input instanceof URL ? input : new URL(input);\n\t\t\n\t\t                // Set url\n\t\t                _this3.url = url;\n\t\t\n\t\t                // Load image\n\t\t                _this3._loadImage(url, reject, resolve);\n\t\t            });\n\t\t        }\n\t\t\n\t\t        // Load from Image object\n\t\t\n\t\t    }, {\n\t\t        key: 'loadFromImage',\n\t\t        value: function loadFromImage(input) {\n\t\t            var _this4 = this;\n\t\t\n\t\t            return new Promise(function (resolve, reject) {\n\t\t                // Bad input type\n\t\t                if (!(input instanceof Image)) {\n\t\t                    reject(new Error('Input param must be a Image object.'));\n\t\t                }\n\t\t\n\t\t                // Set input image\n\t\t                _this4.image = input;\n\t\t\n\t\t                // Process image\n\t\t                _this4._processImage();\n\t\t\n\t\t                // Resolve the promise\n\t\t                resolve(_this4);\n\t\t            });\n\t\t        }\n\t\t    }, {\n\t\t        key: '_processImage',\n\t\t        value: function _processImage() {\n\t\t            // Reset canvas grid\n\t\t            this.canvas = [];\n\t\t            this.pixels = [];\n\t\t\n\t\t            // Calculate grid size\n\t\t            var width = Math.round(this.image.width * this.scaleRatio.x);\n\t\t            var height = Math.round(this.image.height * this.scaleRatio.y);\n\t\t            var cols = Math.ceil(width / this.cellSize);\n\t\t            var rows = Math.ceil(height / this.cellSize);\n\t\t\n\t\t            this.size = { width: width, height: height, cols: cols, rows: rows };\n\t\t\n\t\t            // Create canvas grid\n\t\t            var line = null;\n\t\t            var canvas = null;\n\t\t            var context = null;\n\t\t\n\t\t            var x = null; // cols\n\t\t            var y = null; // rows\n\t\t            var sx = null; // scaled cols\n\t\t            var sy = null; // scaled rows\n\t\t            var sw = null; // scaled width\n\t\t            var sh = null; // scaled height\n\t\t\n\t\t            // For each line\n\t\t            for (y = 0; y < this.size.rows; y++) {\n\t\t                // Reset current line\n\t\t                line = [];\n\t\t\n\t\t                // For each column\n\t\t                for (x = 0; x < this.size.cols; x++) {\n\t\t                    // Create canvas element\n\t\t                    canvas = document.createElement('canvas');\n\t\t\n\t\t                    // Set canvas size\n\t\t                    if (x === 0 || x < this.size.cols - 1) {\n\t\t                        canvas.width = this.size.width < this.cellSize ? this.size.width : this.cellSize;\n\t\t                    } else {\n\t\t                        // Get the rest for the last item (except the first one)\n\t\t                        canvas.width = this.size.width % this.cellSize;\n\t\t                    }\n\t\t\n\t\t                    if (y === 0 || y < this.size.rows - 1) {\n\t\t                        canvas.height = this.size.height < this.cellSize ? this.size.height : this.cellSize;\n\t\t                    } else {\n\t\t                        // Get the rest for the last item (except the first one)\n\t\t                        canvas.height = this.size.height % this.cellSize;\n\t\t                    }\n\t\t\n\t\t                    // Get canvas 2d context\n\t\t                    context = canvas.getContext('2d');\n\t\t\n\t\t                    // Fill withe background (avoid alpha chanel calculation)\n\t\t                    context.fillStyle = 'white';\n\t\t                    context.fillRect(0, 0, canvas.width, canvas.height);\n\t\t\n\t\t                    // Draw the part of image in the canvas (scale)\n\t\t                    sw = canvas.width / this.scaleRatio.x;\n\t\t                    sh = canvas.height / this.scaleRatio.y;\n\t\t                    sx = x * this.cellSize / this.scaleRatio.x;\n\t\t                    sy = y * this.cellSize / this.scaleRatio.y;\n\t\t\n\t\t                    context.drawImage(this.image, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\n\t\t\n\t\t                    // Apply image filters\n\t\t                    (0, _lw2.default)(canvas, this.filters);\n\t\t\n\t\t                    // Add the canvas to current line\n\t\t                    line.push(canvas);\n\t\t                }\n\t\t\n\t\t                // Add the line to canvas grid\n\t\t                this.canvas.push(line);\n\t\t            }\n\t\t        }\n\t\t    }, {\n\t\t        key: 'getPixel',\n\t\t        value: function getPixel(x, y) {\n\t\t            // Test coords validity\n\t\t            x = parseInt(x);\n\t\t            y = parseInt(y);\n\t\t\n\t\t            if (isNaN(x) || isNaN(y)) {\n\t\t                throw new Error('[x, y] params must be Integer.');\n\t\t            }\n\t\t\n\t\t            // Test coords range\n\t\t            if (x < 0 || x >= this.size.width) {\n\t\t                throw new Error('Out of range: x = ' + x + ', max: ' + this.size.width);\n\t\t            }\n\t\t\n\t\t            if (y < 0 || y >= this.size.height) {\n\t\t                throw new Error('Out of range: y = ' + y + ', max: ' + this.size.height);\n\t\t            }\n\t\t\n\t\t            // Calculate target canvas coords\n\t\t            var col = parseInt(x / this.cellSize);\n\t\t            var row = parseInt(y / this.cellSize);\n\t\t\n\t\t            // Adjuste x/y values relative to canvas origin\n\t\t            col && (x -= this.cellSize * col);\n\t\t            row && (y -= this.cellSize * row);\n\t\t\n\t\t            // Get pixel data\n\t\t            var canvas = this.canvas[row][col];\n\t\t            var context = canvas.getContext('2d');\n\t\t            var pixelData = context.getImageData(x, y, 1, 1).data;\n\t\t\n\t\t            return {\n\t\t                color: { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] },\n\t\t                gray: (pixelData[0] + pixelData[1] + pixelData[2]) / 3,\n\t\t                grid: { col: col, row: row },\n\t\t                coords: { x: x, y: y }\n\t\t            };\n\t\t        }\n\t\t    }]);\n\t\t\n\t\t    return CanvasGrid;\n\t\t}();\n\t\t\n\t\t// Exports\n\t\t\n\t\t\n\t\texports.CanvasGrid = CanvasGrid;\n\t\texports.default = CanvasGrid;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\t\tif(true)\n\t\t\t\tmodule.exports = factory();\n\t\t\telse if(typeof define === 'function' && define.amd)\n\t\t\t\tdefine(\"CanvasFilter\", [], factory);\n\t\t\telse if(typeof exports === 'object')\n\t\t\t\texports[\"CanvasFilter\"] = factory();\n\t\t\telse\n\t\t\t\troot[\"CanvasFilter\"] = factory();\n\t\t})(this, function() {\n\t\treturn /******/ (function(modules) { // webpackBootstrap\n\t\t/******/ \t// The module cache\n\t\t/******/ \tvar installedModules = {};\n\t\t/******/\n\t\t/******/ \t// The require function\n\t\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\t/******/\n\t\t/******/ \t\t// Check if module is in cache\n\t\t/******/ \t\tif(installedModules[moduleId])\n\t\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\t/******/\n\t\t/******/ \t\t// Create a new module (and put it into the cache)\n\t\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t\t/******/ \t\t\texports: {},\n\t\t/******/ \t\t\tid: moduleId,\n\t\t/******/ \t\t\tloaded: false\n\t\t/******/ \t\t};\n\t\t/******/\n\t\t/******/ \t\t// Execute the module function\n\t\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t/******/\n\t\t/******/ \t\t// Flag the module as loaded\n\t\t/******/ \t\tmodule.loaded = true;\n\t\t/******/\n\t\t/******/ \t\t// Return the exports of the module\n\t\t/******/ \t\treturn module.exports;\n\t\t/******/ \t}\n\t\t/******/\n\t\t/******/\n\t\t/******/ \t// expose the modules object (__webpack_modules__)\n\t\t/******/ \t__webpack_require__.m = modules;\n\t\t/******/\n\t\t/******/ \t// expose the module cache\n\t\t/******/ \t__webpack_require__.c = installedModules;\n\t\t/******/\n\t\t/******/ \t// __webpack_public_path__\n\t\t/******/ \t__webpack_require__.p = \"\";\n\t\t/******/\n\t\t/******/ \t// Load entry module and return exports\n\t\t/******/ \treturn __webpack_require__(0);\n\t\t/******/ })\n\t\t/************************************************************************/\n\t\t/******/ ([\n\t\t/* 0 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\tmodule.exports = __webpack_require__(1);\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 1 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t'use strict';\n\t\t\t\n\t\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\t    value: true\n\t\t\t});\n\t\t\t// Grayscale algorithms\n\t\t\tvar grayscaleAlgorithms = ['none', 'average', 'desaturation', 'decomposition-min', 'decomposition-max', 'luma', 'luma-601', 'luma-709', 'luma-240', 'red-chanel', 'green-chanel', 'blue-chanel'];\n\t\t\t\n\t\t\t// Trucate color value in the 0-255 range\n\t\t\tfunction color(color) {\n\t\t\t    return color < 0 ? 0 : color > 255 ? 255 : color;\n\t\t\t}\n\t\t\t\n\t\t\t// Filters ...\n\t\t\tfunction invertColor(data, i, value) {\n\t\t\t    if (value) {\n\t\t\t        data[i] = color(255 - data[i]);\n\t\t\t        data[i + 1] = color(255 - data[i + 1]);\n\t\t\t        data[i + 2] = color(255 - data[i + 2]);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction brightness(data, i, value) {\n\t\t\t    if (value !== undefined) {\n\t\t\t        data[i] = color(data[i] + value);\n\t\t\t        data[i + 1] = color(data[i + 1] + value);\n\t\t\t        data[i + 2] = color(data[i + 2] + value);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction contrast(data, i, value) {\n\t\t\t    if (value !== undefined) {\n\t\t\t        data[i] = color(value * (data[i] - 128) + 128);\n\t\t\t        data[i + 1] = color(value * (data[i + 1] - 128) + 128);\n\t\t\t        data[i + 2] = color(value * (data[i + 2] - 128) + 128);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction gamma(data, i, value) {\n\t\t\t    if (value !== undefined) {\n\t\t\t        data[i] = color(Math.exp(Math.log(255 * (data[i] / 255)) * value));\n\t\t\t        data[i + 1] = color(Math.exp(Math.log(255 * (data[i + 1] / 255)) * value));\n\t\t\t        data[i + 2] = color(Math.exp(Math.log(255 * (data[i + 2] / 255)) * value));\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction grayscale(data, i, algorithm, shades) {\n\t\t\t    // Graysale\n\t\t\t    // http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\n\t\t\t\n\t\t\t    // Unsupported algorithm\n\t\t\t    if (grayscaleAlgorithms.indexOf(algorithm) === -1) {\n\t\t\t        throw new Error('Unsupported grayscale algorithm: ' + algorithm);\n\t\t\t    }\n\t\t\t\n\t\t\t    // None\n\t\t\t    if (algorithm === 'none') {\n\t\t\t        return null;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Get Red/Green/Blue values\n\t\t\t    var gray = void 0;\n\t\t\t    var r = data[i];\n\t\t\t    var g = data[i + 1];\n\t\t\t    var b = data[i + 2];\n\t\t\t\n\t\t\t    switch (algorithm) {\n\t\t\t        case 'average':\n\t\t\t            gray = (r + g + b) / 3;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma':\n\t\t\t            // Default\n\t\t\t            gray = r * 0.3 + g * 0.59 + b * 0.11;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma-601':\n\t\t\t            // CCIR-601\n\t\t\t            gray = r * 0.299 + g * 0.587 + b * 0.114;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma-709':\n\t\t\t            // ITU-R-709\n\t\t\t            gray = r * 0.2126 + g * 0.7152 + b * 0.0722;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma-240':\n\t\t\t            // SMPTE-240M\n\t\t\t            gray = r * 0.212 + g * 0.701 + b * 0.087;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'desaturation':\n\t\t\t            gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'decomposition-min':\n\t\t\t            gray = Math.min(r, g, b);\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'decomposition-max':\n\t\t\t            gray = Math.max(r, g, b);\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'red-chanel':\n\t\t\t            gray = r;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'green-chanel':\n\t\t\t            gray = g;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'blue-chanel':\n\t\t\t            gray = b;\n\t\t\t            break;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Shades of gray\n\t\t\t    if (shades !== undefined) {\n\t\t\t        gray = parseInt(gray / shades) * shades;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Force integer\n\t\t\t    gray = parseInt(gray);\n\t\t\t\n\t\t\t    // Set new r/g/b values\n\t\t\t    data[i] = color(gray);\n\t\t\t    data[i + 1] = color(gray);\n\t\t\t    data[i + 2] = color(gray);\n\t\t\t}\n\t\t\t\n\t\t\t// Apply filters on provided canvas\n\t\t\tfunction canvasFilters(canvas, settings) {\n\t\t\t    settings = Object.assign({}, {\n\t\t\t        smoothing: false, // Smoothing [true|fale]\n\t\t\t        brightness: 0, // Image brightness [-255 to +255]\n\t\t\t        contrast: 0, // Image contrast [-255 to +255]\n\t\t\t        gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t\t\t        grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t\t\t        shadesOfGray: 256, // Number of shades of gray [2-256]\n\t\t\t        invertColor: false // Invert color...\n\t\t\t    }, settings || {});\n\t\t\t\n\t\t\t    // Get canvas 2d context\n\t\t\t    var context = canvas.getContext('2d');\n\t\t\t\n\t\t\t    // Smoothing\n\t\t\t    if (context.imageSmoothingEnabled !== undefined) {\n\t\t\t        context.imageSmoothingEnabled = settings.smoothing;\n\t\t\t    } else {\n\t\t\t        context.mozImageSmoothingEnabled = settings.smoothing;\n\t\t\t        context.webkitImageSmoothingEnabled = settings.smoothing;\n\t\t\t        context.msImageSmoothingEnabled = settings.smoothing;\n\t\t\t        context.oImageSmoothingEnabled = settings.smoothing;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Get image data\n\t\t\t    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\t\t\t    var data = imageData.data;\n\t\t\t\n\t\t\t    var contrastFactor = void 0,\n\t\t\t        brightnessOffset = void 0,\n\t\t\t        gammaCorrection = void 0,\n\t\t\t        shadesOfGrayFactor = void 0;\n\t\t\t\n\t\t\t    if (settings.contrast !== 0) {\n\t\t\t        contrastFactor = 259 * (settings.contrast + 255) / (255 * (259 - settings.contrast));\n\t\t\t    }\n\t\t\t\n\t\t\t    if (settings.brightness !== 0) {\n\t\t\t        brightnessOffset = settings.brightness;\n\t\t\t    }\n\t\t\t\n\t\t\t    if (settings.gamma !== 0) {\n\t\t\t        gammaCorrection = 1 / settings.gamma;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Shades of gray\n\t\t\t    if (settings.shadesOfGray > 1 && settings.shadesOfGray < 256) {\n\t\t\t        shadesOfGrayFactor = 255 / (settings.shadesOfGray - 1);\n\t\t\t    }\n\t\t\t\n\t\t\t    // For each pixel\n\t\t\t    for (var i = 0, il = data.length; i < il; i += 4) {\n\t\t\t        // Apply filters\n\t\t\t        invertColor(data, i, settings.invertColor);\n\t\t\t        brightness(data, i, brightnessOffset);\n\t\t\t        contrast(data, i, contrastFactor);\n\t\t\t        gamma(data, i, gammaCorrection);\n\t\t\t        grayscale(data, i, settings.grayscale, shadesOfGrayFactor);\n\t\t\t    }\n\t\t\t\n\t\t\t    // Write new image data on the context\n\t\t\t    context.putImageData(imageData, 0, 0);\n\t\t\t}\n\t\t\t\n\t\t\t// Exports\n\t\t\texports.canvasFilters = canvasFilters;\n\t\t\texports.default = canvasFilters;\n\t\t\n\t\t/***/ }\n\t\t/******/ ])\n\t\t});\n\t\t;\n\t\t//# sourceMappingURL=lw.canvas-filters.js.map\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=lw.canvas-grid.js.map\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.raster-to-gcode.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6d3497b34e19e094fdac","import CanvasGrid from 'lw.canvas-grid'\n\n// RasterToGcode class\nclass RasterToGcode extends CanvasGrid {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = Object.assign({\n            ppi: { x: 254, y: 254 }, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\n            toolDiameter: 0.1,      // Tool diameter in millimeters\n            rapidRate   : 1500,     // Feed rate in mm/min (G0 F value)\n            feedRate    : 500,      // Feed rate in mm/min (G1 F value)\n            rateUnit    : 'mm/min', // Feed rate unit [mm/min, mm/sec]\n\n            beamRange: { min: 0, max: 1 },   // Beam power range (Firmware value)\n            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n\n            milling : false, // EXPERIMENTAL\n            zSafe   : 5,     // Safe Z for fast move\n            zSurface: 0,     // Usinable surface\n            zDepth  : -10,   // Z depth (min:white, max:black)\n\n            offsets  : { X: 0, Y: 0 }, // Global coordinates offsets\n            trimLine : true,           // Trim trailing white pixels\n            joinPixel: true,           // Join consecutive pixels with same intensity\n            burnWhite: true,           // [true = G1 S0 | false = G0] on inner white pixels\n            verboseG : false,          // Output verbose GCode (print each commands)\n            diagonal : false,          // Go diagonally (increase the distance between points)\n            overscan : 0,              // Add some extra white space (in millimeters) before and after each line\n\n            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\n            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\n            filters: {\n                smoothing   : 0,      // Smoothing the input image ?\n                brightness  : 0,      // Image brightness [-255 to +255]\n                contrast    : 0,      // Image contrast [-255 to +255]\n                gamma       : 0,      // Image gamma correction [0.01 to 7.99]\n                grayscale   : 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n                shadesOfGray: 256,    // Number of shades of gray [2-256]\n                invertColor : false   // Invert color...\n            },\n\n            progress       : null, // On progress callbacks\n            progressContext: null, // On progress callback context\n\n            done       : null, // On done callback\n            doneContext: null  // On done callback context\n        }, settings || {})\n\n        // Init properties\n        super(settings)\n\n        // Milling settings\n        if (this.milling) {\n            if (this.zSafe < this.zSurface) {\n                throw new Error('\"zSafe\" must be greater to \"zSurface\"')\n            }\n        }\n\n        // Negative beam size ?\n        if (this.toolDiameter <= 0) {\n            throw new Error('\"toolDiameter\" must be positive')\n        }\n\n        // Uniforme ppi\n        if (! this.ppi.x) {\n            this.ppi = { x: this.ppi, y: this.ppi }\n        }\n\n        // Calculate PPM = Pixel Per Millimeters\n        // this.ppm = 2540 / (this.ppi * 100)\n        // this.ppm = parseFloat(this.ppm.toFixed(10))\n        this.ppm = {\n            x: parseFloat((2540 / (this.ppi.x * 100)).toFixed(10)),\n            y: parseFloat((2540 / (this.ppi.y * 100)).toFixed(10))\n        }\n\n        // Calculate scale ratio\n        this.scaleRatio = {\n            x: this.ppm.x / this.toolDiameter,\n            y: this.ppm.y / this.toolDiameter\n        }\n\n        // State...\n        this.gcode        = null\n        this.currentLine  = null\n        this.lastCommands = null\n\n        // Output size in millimeters\n        this.outputSize = { width : 0, height: 0 }\n\n        // G0 command\n        this.G1 = ['G', 1]\n        this.G0 = ['G', this.burnWhite ? 1 : 0]\n\n        // Calculate beam offset\n        this.beamOffset = this.toolDiameter * 1000 / 2000\n\n        // Calculate real beam range\n        this.realBeamRange = {\n            min: this.beamRange.max / 100 * this.beamPower.min,\n            max: this.beamRange.max / 100 * this.beamPower.max\n        }\n\n        // Adjuste feed rate to mm/min\n        if (this.rateUnit === 'mm/sec') {\n            this.feedRate  *= 60\n            this.rapidRate *= 60\n        }\n\n        // register user callbacks\n        this.progress && this.on('progress', this.progress, this.progressContext)\n        this.done && this.on('done', this.done, this.doneContext)\n    }\n\n    // Process image\n    _processImage() {\n        // Call parent method\n        super._processImage()\n\n        // Calculate output size\n        this.outputSize = {\n            width : this.size.width  * (this.toolDiameter * 1000) / 1000,\n            height: this.size.height * (this.toolDiameter * 1000) / 1000\n        }\n    }\n\n    // Process image and return gcode string\n    run(settings) {\n        // Reset state\n        this.gcode        = []\n        this.lastCommands = {}\n        this.currentLine  = null\n\n        // Defaults settings\n        settings = settings || {}\n\n        // register user callbacks\n        settings.progress && this.on('progress', settings.progress, settings.progressContext)\n        settings.done && this.on('done', settings.done, settings.doneContext)\n\n        let nonBlocking = this.nonBlocking\n\n        if (settings.nonBlocking !== undefined) {\n            nonBlocking = settings.nonBlocking\n        }\n\n        // Add gcode header\n        this._addHeader()\n\n        // Scan type ?\n        if (this.diagonal) {\n            this._scanDiagonally(nonBlocking)\n        }\n        else {\n            this._scanHorizontally(nonBlocking)\n        }\n\n        if (! nonBlocking) {\n            return this.gcode\n        }\n    }\n\n    _addHeader() {\n        // Base headers\n        this.gcode.push(\n            '; Generated by LaserWeb (lw.raster-to-gcode.js)',\n            '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm',\n            '; PPI        : x: ' + this.ppi.x + ' - y: ' + this.ppi.y,\n            '; PPM        : x: ' + this.ppm.x + ' - y: ' + this.ppm.y,\n            '; Tool diam. : ' + this.toolDiameter + ' mm',\n            '; Rapid rate : ' + this.rapidRate + ' ' + this.rateUnit,\n            '; Feed rate  : ' + this.feedRate + ' ' + this.rateUnit\n        )\n\n        if (this.milling) {\n            this.gcode.push(\n                '; Z safe     : ' + this.zSafe,\n                '; Z surface  : ' + this.zSurface,\n                '; Z depth    : ' + this.zDepth\n            )\n        }\n        else {\n            this.gcode.push(\n                '; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max,\n                '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %'\n            )\n        }\n\n        // Print activated options\n        let options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal']\n\n        for (var i = options.length - 1; i >= 0; i--) {\n            if (! this[options[i]]) {\n                options.splice(i, 1)\n            }\n        }\n\n        if (options.length) {\n            this.gcode.push('; Options    : ' + options.join(', '))\n        }\n\n        // Set feed rates\n        this.gcode.push(\n            '',\n            'G0 F' + this.rapidRate,\n            'G1 F' + this.feedRate,\n            ''\n        )\n    }\n\n    // Map S value to pixel power\n    _mapPixelPower(value) {\n        let range = this.milling ? { min: 0, max: this.zDepth } : this.realBeamRange\n        return value * (range.max - range.min) / 255 + range.min\n    }\n\n    // Compute and return a command, return null if not changed\n    _command(name, value) {\n        // If the value argument is an object\n        if (typeof value === 'object') {\n            // Computed commands line\n            let commands = Array.prototype.slice.call(arguments)\n            let command, line = []\n\n            // for each command\n            for (var i = 0, il = commands.length; i < il; i++) {\n                command = this._command.apply(this, commands[i])\n                command && line.push(command)\n            }\n\n            // Return the line if not empty\n            return line.length ? line.join(' ') : null\n        }\n\n        // Format the value\n        value = value.toFixed(this.precision[name] || 0)\n\n        // If the value was changed or if verbose mode on\n        if (this.verboseG || value !== this.lastCommands[name]) {\n            this.lastCommands[name] = value\n            return name + value\n        }\n\n        // No change\n        return null\n    }\n\n    // Get a pixel power value from the canvas data grid\n    _getPixelPower(x, y, defaultValue) {\n        try {\n            // Reverse Y value since canvas as top/left origin\n            y = this.size.height - y - 1;\n\n            // Get pixel info\n            let pixel = this.getPixel(x, y)\n\n            // Reversed gray value [ 0 = white | 255 = black ]\n            return 255 - pixel.gray\n        }\n        catch (error) {\n            if (arguments.length === 3) {\n                return defaultValue\n            }\n            throw error\n        }\n    }\n\n    // Get a point from the current line with real world coordinates\n    _getPoint(index) {\n        // Get the point object from the current line\n        let point = this.currentLine[index]\n\n        // No point\n        if (! point) {\n            return null\n        }\n\n        // Commands\n        point.G = point.s ? ['G', 1] : this.G0\n        point.X = (point.x * this.toolDiameter) + this.offsets.X\n        point.Y = (point.y * this.toolDiameter) + this.offsets.Y\n        point.S = this._mapPixelPower(point.s)\n\n        // Offsets\n        if (this.diagonal) {\n            // Vertical offset\n            point.Y += this.toolDiameter\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n                point.Y -= this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n                point.Y += this.beamOffset\n            }\n        }\n        else {\n            // Vertical offset\n            point.Y += this.beamOffset\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n            }\n        }\n\n        // Return the point\n        return point\n    }\n\n    // Remove all trailing white spaces from the current line\n    _trimCurrentLine() {\n        // Remove white spaces from the left\n        let point = this.currentLine[0]\n\n        while (point && ! point.p) {\n            this.currentLine.shift()\n            point = this.currentLine[0]\n        }\n\n        // Remove white spaces from the right\n        point = this.currentLine[this.currentLine.length - 2]\n\n        while (point && ! point.p) {\n            this.currentLine.pop()\n            point = this.currentLine[this.currentLine.length - 2]\n        }\n\n        // Return the new line length\n        return this.currentLine.length\n    }\n\n    // Join pixel with same power\n    _reduceCurrentLine() {\n        // Line too short to be reduced\n        if (this.currentLine.length < 3) {\n            return this.currentLine.length\n        }\n\n        // Extract all points exept the first one\n        let points = this.currentLine.splice(1)\n\n        // Get current power\n        let power = this.currentLine[0].p\n\n        // For each extracted point\n        for (var point, i = 0, il = points.length - 1; i < il; i++) {\n            // Current point\n            point = points[i]\n\n            // On power change\n            if (power !== point.p) {\n                this.currentLine.push(point)\n            }\n\n            // Update power\n            power = point.p\n        }\n\n        // Add last point\n        this.currentLine.push(points[i])\n    }\n\n    // Add extra white pixels at the ends\n    _overscanCurrentLine(reversed) {\n        // Number of pixels to add on each side\n        let pixels = this.overscan / this.ppm.x\n\n        // Get first/last point\n        let firstPoint = this.currentLine[0]\n        let lastPoint  = this.currentLine[this.currentLine.length - 1]\n\n        // Is last white/colored point ?\n        firstPoint.s && (firstPoint.lastWhite  = true)\n        lastPoint.s  && (lastPoint.lastColored = true)\n\n        // Reversed line ?\n        reversed ? (lastPoint.s = 0) : (firstPoint.s = 0)\n\n        // Create left/right points\n        let rightPoint = { x: lastPoint.x + pixels , y: lastPoint.y , s: 0, p: 0 }\n        let leftPoint  = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 }\n\n        if (this.diagonal) {\n            leftPoint.y  += pixels\n            rightPoint.y -= pixels\n        }\n\n        // Add left/right points to current line\n        this.currentLine.unshift(leftPoint)\n        this.currentLine.push(rightPoint)\n    }\n\n    // Process current line and return an array of GCode text lines\n    _processCurrentLine(reversed) {\n        // Trim trailing white spaces ?\n        if ((this.milling || this.trimLine) && ! this._trimCurrentLine()) {\n            // Skip empty line\n            return null\n        }\n\n        // Join pixel with same power\n        if (this.joinPixel) {\n            this._reduceCurrentLine()\n        }\n\n        // Overscan ?\n        if (this.overscan) {\n            this._overscanCurrentLine(reversed)\n        }\n\n        // Mark first and last point on the current line\n        this.currentLine[0].first = true\n        this.currentLine[this.currentLine.length - 1].last = true\n\n        // Reversed line ?\n        if (reversed) {\n            this.currentLine = this.currentLine.reverse()\n        }\n\n        // Point index\n        let point, index = 0\n\n        // Init loop vars...\n        let command, gcode = []\n\n        let addCommand = (...args) => {\n            command = this._command(...args)\n            command && gcode.push(command)\n        }\n\n        // Get first point\n        point = this._getPoint(index)\n\n        // Action\n        if (this.milling) {\n            let plung     = false\n            let lastPoint = null\n\n            // Move to start of the line\n            addCommand(['G', 0], ['Z', this.zSafe])\n            addCommand(['G', 0], ['X', point.X], ['Y', point.Y])\n            addCommand(['G', 0], ['Z', this.zSurface])\n\n            // For each point on the line\n            while (point) {\n                if (point.S) {\n                    if (plung) {\n                        addCommand(['G', 0], ['Z', this.zSurface])\n                        plung = false\n                    }\n\n                    addCommand(['G', 1], ['Z', this.zSurface + point.S])\n                    addCommand(['G', 1], ['X', point.X], ['Y', point.Y])\n                }\n                else {\n                    if (plung) {\n                        addCommand(['G', 1], ['Z', this.zSurface])\n                        plung = false\n                    }\n\n                    addCommand(['G', 0], ['Z', this.zSafe])\n                    addCommand(['G', 0], ['X', point.X], ['Y', point.Y])\n                }\n\n                if (point.lastWhite || point.lastColored) {\n                    plung = true\n                }\n\n                // Get next point\n                lastPoint = point\n                point     = this._getPoint(++index)\n            }\n\n            // Move to Z safe\n            addCommand(['G', 1], ['Z', this.zSurface])\n            addCommand(['G', 0], ['Z', this.zSafe])\n        }\n        else {\n            // Move to start of the line\n            addCommand(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0])\n\n            // For each point on the line\n            while (point) {\n                // Burn to next point\n                addCommand(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S])\n\n                // Get next point\n                point = this._getPoint(++index)\n            }\n        }\n\n        // Return gcode commands array\n        if (gcode.length) {\n            return gcode\n        }\n\n        // Empty line\n        return null\n    }\n\n    // Parse horizontally\n    _scanHorizontally(nonBlocking) {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = () => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // For each pixel on the line\n            for (x = 0; x <= w; x++) {\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && ! point.p && p\n                lastColored = point && point.p && ! p\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add point to current line\n                this.currentLine.push(point)\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((y / h) * 100)\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            computeCurrentLine()\n            processCurrentLine()\n\n            y++\n\n            if (y < h) {\n                if (nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                this._onDone({ gcode: this.gcode })\n            }\n        }\n\n        processNextLine()\n\n        // // For each image line\n        // for (y = 0; y < h; y++) {\n        //     processNextLine()\n        // }\n    }\n\n    // Parse diagonally\n    _scanDiagonally(nonBlocking) {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let totalLines  = w + h - 1\n        let lineNum     = 0\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = (x, y) => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // Increment line num\n            lineNum++\n\n            while(true) {\n                // Y limit reached !\n                if (y < -1 || y == h) {\n                    break\n                }\n\n                // X limit reached !\n                if (x < 0 || x > w) {\n                    break\n                }\n\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && (! point.p && p)\n                lastColored = point && (point.p && ! p)\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add the new point\n                this.currentLine.push(point)\n\n                // Next coords\n                x++\n                y--\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((lineNum / totalLines) * 100)\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            computeCurrentLine(x, y)\n            processCurrentLine()\n\n            if (! x) y++\n            else x++\n\n            if (y === h) {\n                x++\n                y--\n            }\n\n            if (y < h && x < w) {\n                if (nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                this._onDone({ gcode: this.gcode })\n            }\n        }\n\n        processNextLine()\n\n        // // For each image line\n        // for (y = 0; y < h; y++) {\n        //     scanDiagonalLine(x, y)\n        // }\n        //\n        // // For each image column (exept the first one)\n        // for (x = 1, y--; x < w; x++) {\n        //     scanDiagonalLine(x, y)\n        // }\n    }\n\n    _onProgress(event) {\n        //console.log('progress:', event.percent);\n    }\n\n    _onDone(event) {\n        //console.log('done:', event.gcode.length);\n    }\n\n    on(event, callback, context) {\n        let method = '_on' + event[0].toUpperCase() + event.slice(1)\n\n        if (! this[method] || typeof this[method] !== 'function') {\n            throw new Error('Undefined event: ' + event)\n        }\n\n        this[method] = event => callback.call(context || this, event)\n\n        return this\n    }\n\n    // Return the bitmap height-map\n    getHeightMap(settings) {\n        // Init loop vars{\n        let heightMap = []\n        let x = 0\n        let y = 0\n        let w = this.size.width\n        let h = this.size.height\n\n        let percent     = 0\n        let lastPercent = 0\n\n        // Defaults settings\n        settings = settings || {}\n\n        // register user callbacks\n        let onProgress = settings.progress || function() {}\n        let onDone     = settings.done     || function() {}\n\n        // Non blocking mode ?\n        let nonBlocking = this.nonBlocking\n\n        if (settings.nonBlocking !== undefined) {\n            nonBlocking = settings.nonBlocking\n        }\n\n        let computeCurrentLine = () => {\n            // Reset current line\n            let pixels = []\n\n            // For each pixel on the line\n            for (x = 0; x < w; x++) {\n                pixels.push(this._mapPixelPower(this._getPixelPower(x, y)))\n            }\n\n            // Call progress callback\n            percent = Math.round((y / h) * 100)\n\n            if (percent > lastPercent) {\n                onProgress.call(settings.progressContext || this, { pixels, percent })\n            }\n\n            lastPercent = percent\n\n            // Add pixels line\n            heightMap.push(pixels)\n        }\n\n        let processNextLine = () => {\n            computeCurrentLine()\n\n            y++\n\n            if (y < h) {\n                if (nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                onDone.call(settings.doneContext || this, { heightMap })\n            }\n        }\n\n        processNextLine()\n\n        if (! nonBlocking) {\n            return heightMap\n        }\n    }\n}\n\n// Exports\nexport { RasterToGcode }\nexport default RasterToGcode\n\n\n\n// WEBPACK FOOTER //\n// ./raster-to-gcode.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"CanvasGrid\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CanvasGrid\"] = factory();\n\telse\n\t\troot[\"CanvasGrid\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.CanvasGrid = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _lw = __webpack_require__(2);\n\t\n\tvar _lw2 = _interopRequireDefault(_lw);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// CanvasGrid class\n\tvar CanvasGrid = function () {\n\t    // Class constructor...\n\t    function CanvasGrid(settings) {\n\t        _classCallCheck(this, CanvasGrid);\n\t\n\t        // Init properties\n\t        this.cellSize = 1024;\n\t        this.scaleRatio = { x: 1, y: 1 };\n\t        this.filters = {};\n\t\n\t        Object.assign(this, settings || {});\n\t\n\t        if (!this.scaleRatio.x) {\n\t            this.scaleRatio = { x: this.scaleRatio, y: this.scaleRatio };\n\t        }\n\t\n\t        this.size = { width: 0, height: 0, cols: 0, rows: 0 };\n\t        this.file = null;\n\t        this.image = null;\n\t        this.url = null;\n\t        this.canvas = [];\n\t        this.pixels = [];\n\t    }\n\t\n\t    // <input> can be Image, File, URL object or URL string (http://* or data:image/*)\n\t\n\t\n\t    _createClass(CanvasGrid, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load Image object\n\t            if (input instanceof Image) {\n\t                return this.loadFromImage(input);\n\t            }\n\t\n\t            // Load URL object\n\t            if (typeof input === 'string' || input instanceof URL) {\n\t                return this.loadFromURL(input.trim());\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load image\n\t\n\t    }, {\n\t        key: '_loadImage',\n\t        value: function _loadImage(src, reject, resolve) {\n\t            var _this = this;\n\t\n\t            // Create Image object\n\t            var image = new Image();\n\t\n\t            // Register for load and error events\n\t            image.onload = function (event) {\n\t                _this.loadFromImage(image).then(resolve).catch(reject);\n\t            };\n\t\n\t            image.onerror = function (event) {\n\t                reject(new Error('An error occurred while loading the image : ' + src));\n\t            };\n\t\n\t            // Load the image from File url\n\t            image.src = src;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Set input file\n\t                _this2.file = input;\n\t\n\t                // Load image\n\t                _this2._loadImage(URL.createObjectURL(input), reject, resolve);\n\t            });\n\t        }\n\t\n\t        // Load from URL object or string\n\t\n\t    }, {\n\t        key: 'loadFromURL',\n\t        value: function loadFromURL(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof URL) && typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a URL string or object.'));\n\t                }\n\t\n\t                // Create url object\n\t                var url = input instanceof URL ? input : new URL(input);\n\t\n\t                // Set url\n\t                _this3.url = url;\n\t\n\t                // Load image\n\t                _this3._loadImage(url, reject, resolve);\n\t            });\n\t        }\n\t\n\t        // Load from Image object\n\t\n\t    }, {\n\t        key: 'loadFromImage',\n\t        value: function loadFromImage(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Image)) {\n\t                    reject(new Error('Input param must be a Image object.'));\n\t                }\n\t\n\t                // Set input image\n\t                _this4.image = input;\n\t\n\t                // Process image\n\t                _this4._processImage();\n\t\n\t                // Resolve the promise\n\t                resolve(_this4);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_processImage',\n\t        value: function _processImage() {\n\t            // Reset canvas grid\n\t            this.canvas = [];\n\t            this.pixels = [];\n\t\n\t            // Calculate grid size\n\t            var width = Math.round(this.image.width * this.scaleRatio.x);\n\t            var height = Math.round(this.image.height * this.scaleRatio.y);\n\t            var cols = Math.ceil(width / this.cellSize);\n\t            var rows = Math.ceil(height / this.cellSize);\n\t\n\t            this.size = { width: width, height: height, cols: cols, rows: rows };\n\t\n\t            // Create canvas grid\n\t            var line = null;\n\t            var canvas = null;\n\t            var context = null;\n\t\n\t            var x = null; // cols\n\t            var y = null; // rows\n\t            var sx = null; // scaled cols\n\t            var sy = null; // scaled rows\n\t            var sw = null; // scaled width\n\t            var sh = null; // scaled height\n\t\n\t            // For each line\n\t            for (y = 0; y < this.size.rows; y++) {\n\t                // Reset current line\n\t                line = [];\n\t\n\t                // For each column\n\t                for (x = 0; x < this.size.cols; x++) {\n\t                    // Create canvas element\n\t                    canvas = document.createElement('canvas');\n\t\n\t                    // Set canvas size\n\t                    if (x === 0 || x < this.size.cols - 1) {\n\t                        canvas.width = this.size.width < this.cellSize ? this.size.width : this.cellSize;\n\t                    } else {\n\t                        // Get the rest for the last item (except the first one)\n\t                        canvas.width = this.size.width % this.cellSize;\n\t                    }\n\t\n\t                    if (y === 0 || y < this.size.rows - 1) {\n\t                        canvas.height = this.size.height < this.cellSize ? this.size.height : this.cellSize;\n\t                    } else {\n\t                        // Get the rest for the last item (except the first one)\n\t                        canvas.height = this.size.height % this.cellSize;\n\t                    }\n\t\n\t                    // Get canvas 2d context\n\t                    context = canvas.getContext('2d');\n\t\n\t                    // Fill withe background (avoid alpha chanel calculation)\n\t                    context.fillStyle = 'white';\n\t                    context.fillRect(0, 0, canvas.width, canvas.height);\n\t\n\t                    // Draw the part of image in the canvas (scale)\n\t                    sw = canvas.width / this.scaleRatio.x;\n\t                    sh = canvas.height / this.scaleRatio.y;\n\t                    sx = x * this.cellSize / this.scaleRatio.x;\n\t                    sy = y * this.cellSize / this.scaleRatio.y;\n\t\n\t                    context.drawImage(this.image, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\n\t\n\t                    // Apply image filters\n\t                    (0, _lw2.default)(canvas, this.filters);\n\t\n\t                    // Add the canvas to current line\n\t                    line.push(canvas);\n\t                }\n\t\n\t                // Add the line to canvas grid\n\t                this.canvas.push(line);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getPixel',\n\t        value: function getPixel(x, y) {\n\t            // Test coords validity\n\t            x = parseInt(x);\n\t            y = parseInt(y);\n\t\n\t            if (isNaN(x) || isNaN(y)) {\n\t                throw new Error('[x, y] params must be Integer.');\n\t            }\n\t\n\t            // Test coords range\n\t            if (x < 0 || x >= this.size.width) {\n\t                throw new Error('Out of range: x = ' + x + ', max: ' + this.size.width);\n\t            }\n\t\n\t            if (y < 0 || y >= this.size.height) {\n\t                throw new Error('Out of range: y = ' + y + ', max: ' + this.size.height);\n\t            }\n\t\n\t            // Calculate target canvas coords\n\t            var col = parseInt(x / this.cellSize);\n\t            var row = parseInt(y / this.cellSize);\n\t\n\t            // Adjuste x/y values relative to canvas origin\n\t            col && (x -= this.cellSize * col);\n\t            row && (y -= this.cellSize * row);\n\t\n\t            // Get pixel data\n\t            var canvas = this.canvas[row][col];\n\t            var context = canvas.getContext('2d');\n\t            var pixelData = context.getImageData(x, y, 1, 1).data;\n\t\n\t            return {\n\t                color: { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] },\n\t                gray: (pixelData[0] + pixelData[1] + pixelData[2]) / 3,\n\t                grid: { col: col, row: row },\n\t                coords: { x: x, y: y }\n\t            };\n\t        }\n\t    }]);\n\t\n\t    return CanvasGrid;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.CanvasGrid = CanvasGrid;\n\texports.default = CanvasGrid;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(\"CanvasFilter\", [], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"CanvasFilter\"] = factory();\n\t\telse\n\t\t\troot[\"CanvasFilter\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t    value: true\n\t\t});\n\t\t// Grayscale algorithms\n\t\tvar grayscaleAlgorithms = ['none', 'average', 'desaturation', 'decomposition-min', 'decomposition-max', 'luma', 'luma-601', 'luma-709', 'luma-240', 'red-chanel', 'green-chanel', 'blue-chanel'];\n\t\t\n\t\t// Trucate color value in the 0-255 range\n\t\tfunction color(color) {\n\t\t    return color < 0 ? 0 : color > 255 ? 255 : color;\n\t\t}\n\t\t\n\t\t// Filters ...\n\t\tfunction invertColor(data, i, value) {\n\t\t    if (value) {\n\t\t        data[i] = color(255 - data[i]);\n\t\t        data[i + 1] = color(255 - data[i + 1]);\n\t\t        data[i + 2] = color(255 - data[i + 2]);\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction brightness(data, i, value) {\n\t\t    if (value !== undefined) {\n\t\t        data[i] = color(data[i] + value);\n\t\t        data[i + 1] = color(data[i + 1] + value);\n\t\t        data[i + 2] = color(data[i + 2] + value);\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction contrast(data, i, value) {\n\t\t    if (value !== undefined) {\n\t\t        data[i] = color(value * (data[i] - 128) + 128);\n\t\t        data[i + 1] = color(value * (data[i + 1] - 128) + 128);\n\t\t        data[i + 2] = color(value * (data[i + 2] - 128) + 128);\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction gamma(data, i, value) {\n\t\t    if (value !== undefined) {\n\t\t        data[i] = color(Math.exp(Math.log(255 * (data[i] / 255)) * value));\n\t\t        data[i + 1] = color(Math.exp(Math.log(255 * (data[i + 1] / 255)) * value));\n\t\t        data[i + 2] = color(Math.exp(Math.log(255 * (data[i + 2] / 255)) * value));\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction grayscale(data, i, algorithm, shades) {\n\t\t    // Graysale\n\t\t    // http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\n\t\t\n\t\t    // Unsupported algorithm\n\t\t    if (grayscaleAlgorithms.indexOf(algorithm) === -1) {\n\t\t        throw new Error('Unsupported grayscale algorithm: ' + algorithm);\n\t\t    }\n\t\t\n\t\t    // None\n\t\t    if (algorithm === 'none') {\n\t\t        return null;\n\t\t    }\n\t\t\n\t\t    // Get Red/Green/Blue values\n\t\t    var gray = void 0;\n\t\t    var r = data[i];\n\t\t    var g = data[i + 1];\n\t\t    var b = data[i + 2];\n\t\t\n\t\t    switch (algorithm) {\n\t\t        case 'average':\n\t\t            gray = (r + g + b) / 3;\n\t\t            break;\n\t\t\n\t\t        case 'luma':\n\t\t            // Default\n\t\t            gray = r * 0.3 + g * 0.59 + b * 0.11;\n\t\t            break;\n\t\t\n\t\t        case 'luma-601':\n\t\t            // CCIR-601\n\t\t            gray = r * 0.299 + g * 0.587 + b * 0.114;\n\t\t            break;\n\t\t\n\t\t        case 'luma-709':\n\t\t            // ITU-R-709\n\t\t            gray = r * 0.2126 + g * 0.7152 + b * 0.0722;\n\t\t            break;\n\t\t\n\t\t        case 'luma-240':\n\t\t            // SMPTE-240M\n\t\t            gray = r * 0.212 + g * 0.701 + b * 0.087;\n\t\t            break;\n\t\t\n\t\t        case 'desaturation':\n\t\t            gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n\t\t            break;\n\t\t\n\t\t        case 'decomposition-min':\n\t\t            gray = Math.min(r, g, b);\n\t\t            break;\n\t\t\n\t\t        case 'decomposition-max':\n\t\t            gray = Math.max(r, g, b);\n\t\t            break;\n\t\t\n\t\t        case 'red-chanel':\n\t\t            gray = r;\n\t\t            break;\n\t\t\n\t\t        case 'green-chanel':\n\t\t            gray = g;\n\t\t            break;\n\t\t\n\t\t        case 'blue-chanel':\n\t\t            gray = b;\n\t\t            break;\n\t\t    }\n\t\t\n\t\t    // Shades of gray\n\t\t    if (shades !== undefined) {\n\t\t        gray = parseInt(gray / shades) * shades;\n\t\t    }\n\t\t\n\t\t    // Force integer\n\t\t    gray = parseInt(gray);\n\t\t\n\t\t    // Set new r/g/b values\n\t\t    data[i] = color(gray);\n\t\t    data[i + 1] = color(gray);\n\t\t    data[i + 2] = color(gray);\n\t\t}\n\t\t\n\t\t// Apply filters on provided canvas\n\t\tfunction canvasFilters(canvas, settings) {\n\t\t    settings = Object.assign({}, {\n\t\t        smoothing: false, // Smoothing [true|fale]\n\t\t        brightness: 0, // Image brightness [-255 to +255]\n\t\t        contrast: 0, // Image contrast [-255 to +255]\n\t\t        gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t\t        grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t\t        shadesOfGray: 256, // Number of shades of gray [2-256]\n\t\t        invertColor: false // Invert color...\n\t\t    }, settings || {});\n\t\t\n\t\t    // Get canvas 2d context\n\t\t    var context = canvas.getContext('2d');\n\t\t\n\t\t    // Smoothing\n\t\t    if (context.imageSmoothingEnabled !== undefined) {\n\t\t        context.imageSmoothingEnabled = settings.smoothing;\n\t\t    } else {\n\t\t        context.mozImageSmoothingEnabled = settings.smoothing;\n\t\t        context.webkitImageSmoothingEnabled = settings.smoothing;\n\t\t        context.msImageSmoothingEnabled = settings.smoothing;\n\t\t        context.oImageSmoothingEnabled = settings.smoothing;\n\t\t    }\n\t\t\n\t\t    // Get image data\n\t\t    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\t\t    var data = imageData.data;\n\t\t\n\t\t    var contrastFactor = void 0,\n\t\t        brightnessOffset = void 0,\n\t\t        gammaCorrection = void 0,\n\t\t        shadesOfGrayFactor = void 0;\n\t\t\n\t\t    if (settings.contrast !== 0) {\n\t\t        contrastFactor = 259 * (settings.contrast + 255) / (255 * (259 - settings.contrast));\n\t\t    }\n\t\t\n\t\t    if (settings.brightness !== 0) {\n\t\t        brightnessOffset = settings.brightness;\n\t\t    }\n\t\t\n\t\t    if (settings.gamma !== 0) {\n\t\t        gammaCorrection = 1 / settings.gamma;\n\t\t    }\n\t\t\n\t\t    // Shades of gray\n\t\t    if (settings.shadesOfGray > 1 && settings.shadesOfGray < 256) {\n\t\t        shadesOfGrayFactor = 255 / (settings.shadesOfGray - 1);\n\t\t    }\n\t\t\n\t\t    // For each pixel\n\t\t    for (var i = 0, il = data.length; i < il; i += 4) {\n\t\t        // Apply filters\n\t\t        invertColor(data, i, settings.invertColor);\n\t\t        brightness(data, i, brightnessOffset);\n\t\t        contrast(data, i, contrastFactor);\n\t\t        gamma(data, i, gammaCorrection);\n\t\t        grayscale(data, i, settings.grayscale, shadesOfGrayFactor);\n\t\t    }\n\t\t\n\t\t    // Write new image data on the context\n\t\t    context.putImageData(imageData, 0, 0);\n\t\t}\n\t\t\n\t\t// Exports\n\t\texports.canvasFilters = canvasFilters;\n\t\texports.default = canvasFilters;\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=lw.canvas-filters.js.map\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=lw.canvas-grid.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.canvas-grid/dist/lw.canvas-grid.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}