{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.raster-to-gcode.min.js","webpack:///webpack/bootstrap 0ec33232458f80da9da6","webpack:///./raster-to-gcode.js","webpack:///../~/lw.canvas-grid/dist/lw.canvas-grid.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","RasterToGcode","undefined","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_lw","_lw2","_CanvasGrid","settings","assign","ppi","x","y","beamSize","beamRange","min","max","beamPower","feedRate","feedUnit","offsets","X","Y","trimLine","joinPixel","burnWhite","verboseG","diagonal","precision","S","nonBlocking","filters","smoothing","brightness","contrast","gamma","grayscale","shadesOfGray","progress","progressContext","done","doneContext","_this","ppm","parseFloat","toFixed","scaleRatio","gcode","currentLine","lastCommands","outputSize","width","height","G1","G0","beamOffset","realBeamRange","on","size","_addHeader","_scanDiagonally","_scanHorizontally","push","options","splice","join","name","commands","Array","slice","arguments","command","line","il","_command","apply","defaultValue","pixel","getPixel","gray","error","index","point","G","s","_mapPixelPower","first","lastWhite","last","lastColored","shift","pop","points","power","reversed","pixels","overscan","firstPoint","lastPoint","rightPoint","leftPoint","unshift","_trimCurrentLine","_reduceCurrentLine","_overscanCurrentLine","reverse","_getPoint","_this2","w","h","computeCurrentLine","_getPixelPower","percent","lastPercent","processCurrentLine","_processCurrentLine","Math","round","_onProgress","processNextLine","setTimeout","_onDone","_this3","totalLines","lineNum","event","callback","context","_this4","method","toUpperCase","Error","CanvasGrid","cellSize","cols","rows","file","image","url","canvas","input","File","loadFromFile","Image","loadFromImage","URL","loadFromURL","trim","Promise","reject","src","resolve","onload","then","catch","onerror","_loadImage","createObjectURL","_processImage","ceil","sx","sy","sw","sh","document","createElement","getContext","fillStyle","fillRect","drawImage","parseInt","isNaN","col","row","pixelData","getImageData","data","color","r","g","b","a","grid","coords","exp","log","algorithm","shades","grayscaleAlgorithms","indexOf","canvasFilters","imageSmoothingEnabled","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","oImageSmoothingEnabled","imageData","contrastFactor","brightnessOffset","gammaCorrection","shadesOfGrayFactor","putImageData"],"mappings":"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","file":"lw.raster-to-gcode.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"RasterToGcode\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RasterToGcode\"] = factory();\n\telse\n\t\troot[\"RasterToGcode\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"RasterToGcode\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RasterToGcode\"] = factory();\n\telse\n\t\troot[\"RasterToGcode\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.RasterToGcode = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _lw = __webpack_require__(2);\n\t\n\tvar _lw2 = _interopRequireDefault(_lw);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// RasterToGcode class\n\tvar RasterToGcode = function (_CanvasGrid) {\n\t    _inherits(RasterToGcode, _CanvasGrid);\n\t\n\t    // Class constructor...\n\t    function RasterToGcode(settings) {\n\t        _classCallCheck(this, RasterToGcode);\n\t\n\t        // Defaults settings\n\t        settings = Object.assign({\n\t            ppi: { x: 254, y: 254 }, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\t\n\t            beamSize: 0.1, // Beam size in millimeters\n\t            beamRange: { min: 0, max: 1 }, // Beam power range (Firmware value)\n\t            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n\t            feedRate: 1500, // Feed rate in mm/min (F value)\n\t            feedUnit: 'mm/min', // Feed rate unit [mm/min, mm/sec]\n\t\n\t            offsets: { X: 0, Y: 0 }, // Global coordinates offsets\n\t            trimLine: true, // Trim trailing white pixels\n\t            joinPixel: true, // Join consecutive pixels with same intensity\n\t            burnWhite: true, // [true = G1 S0 | false = G0] on inner white pixels\n\t            verboseG: false, // Output verbose GCode (print each commands)\n\t            diagonal: false, // Go diagonally (increase the distance between points)\n\t\n\t            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\t\n\t            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\t\n\t            filters: {\n\t                smoothing: 0, // Smoothing the input image ?\n\t                brightness: 0, // Image brightness [-255 to +255]\n\t                contrast: 0, // Image contrast [-255 to +255]\n\t                gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t                grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t                shadesOfGray: 256 // Number of shades of gray [2-256]\n\t            },\n\t\n\t            progress: null, // On progress callbacks\n\t            progressContext: null, // On progress callback context\n\t\n\t            done: null, // On done callback\n\t            doneContext: null // On done callback context\n\t        }, settings || {});\n\t\n\t        // Init properties\n\t\n\t        // Uniforme ppi\n\t        var _this = _possibleConstructorReturn(this, (RasterToGcode.__proto__ || Object.getPrototypeOf(RasterToGcode)).call(this, settings));\n\t\n\t        if (!_this.ppi.x) {\n\t            _this.ppi = { x: _this.ppi, y: _this.ppi };\n\t        }\n\t\n\t        // Calculate PPM = Pixel Per Millimeters\n\t        // this.ppm = 2540 / (this.ppi * 100)\n\t        // this.ppm = parseFloat(this.ppm.toFixed(10))\n\t        _this.ppm = {\n\t            x: parseFloat((2540 / (_this.ppi.x * 100)).toFixed(10)),\n\t            y: parseFloat((2540 / (_this.ppi.y * 100)).toFixed(10))\n\t        };\n\t\n\t        // Calculate scale ratio\n\t        _this.scaleRatio = {\n\t            x: _this.ppm.x / _this.beamSize,\n\t            y: _this.ppm.y / _this.beamSize\n\t        };\n\t\n\t        // State...\n\t        _this.gcode = null;\n\t        _this.currentLine = null;\n\t        _this.lastCommands = null;\n\t\n\t        // Output size in millimeters\n\t        _this.outputSize = { width: 0, height: 0 };\n\t\n\t        // G0 command\n\t        _this.G1 = ['G', 1];\n\t        _this.G0 = ['G', _this.burnWhite ? 1 : 0];\n\t\n\t        // Calculate beam offset\n\t        _this.beamOffset = _this.beamSize * 1000 / 2000;\n\t\n\t        // Calculate real beam range\n\t        _this.realBeamRange = {\n\t            min: _this.beamRange.max / 100 * _this.beamPower.min,\n\t            max: _this.beamRange.max / 100 * _this.beamPower.max\n\t        };\n\t\n\t        // Adjuste feed rate to mm/min\n\t        if (_this.feedUnit === 'mm/sec') {\n\t            _this.feedRate *= 60;\n\t        }\n\t\n\t        // register user callbacks\n\t        _this.progress && _this.on('progress', _this.progress, _this.progressContext);\n\t        _this.done && _this.on('done', _this.done, _this.doneContext);\n\t        return _this;\n\t    }\n\t\n\t    // Process image\n\t\n\t\n\t    _createClass(RasterToGcode, [{\n\t        key: '_processImage',\n\t        value: function _processImage() {\n\t            // Call parent method\n\t            _get(RasterToGcode.prototype.__proto__ || Object.getPrototypeOf(RasterToGcode.prototype), '_processImage', this).call(this);\n\t\n\t            // Calculate output size\n\t            this.outputSize = {\n\t                width: this.size.width * (this.beamSize * 1000) / 1000,\n\t                height: this.size.height * (this.beamSize * 1000) / 1000\n\t            };\n\t        }\n\t\n\t        // Process image and return gcode string\n\t\n\t    }, {\n\t        key: 'run',\n\t        value: function run(progress, done) {\n\t            // Reset state\n\t            this.gcode = [];\n\t            this.lastCommands = {};\n\t            this.currentLine = null;\n\t\n\t            // register user callbacks\n\t            progress && this.on('progress', progress);\n\t            done && this.on('done', done);\n\t\n\t            // Add gcode header\n\t            this._addHeader();\n\t\n\t            // Scan type ?\n\t            if (this.diagonal) {\n\t                this._scanDiagonally();\n\t            } else {\n\t                this._scanHorizontally();\n\t            }\n\t\n\t            if (!this.nonBlocking) {\n\t                return this.gcode;\n\t            }\n\t        }\n\t    }, {\n\t        key: '_addHeader',\n\t        value: function _addHeader() {\n\t            // Base headers\n\t            this.gcode.push('; Generated by LaserWeb (lw.raster-to-gcode.js)', '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm', '; PPI        : x: ' + this.ppi.x + ' - y: ' + this.ppi.y, '; PPM        : x: ' + this.ppm.x + ' - y: ' + this.ppm.y, '; Beam size  : ' + this.beamSize + ' mm', '; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max, '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %', '; Feed rate  : ' + this.feedRate + ' mm/min');\n\t\n\t            // Print activated options\n\t            var options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal'];\n\t\n\t            for (var i = options.length - 1; i >= 0; i--) {\n\t                if (!this[options[i]]) {\n\t                    options.splice(i, 1);\n\t                }\n\t            }\n\t\n\t            if (options.length) {\n\t                this.gcode.push('; Options    : ' + options.join(', '));\n\t            }\n\t\n\t            // Set feed rates\n\t            this.gcode.push('', 'G0 F' + this.feedRate, 'G1 F' + this.feedRate, '');\n\t        }\n\t\n\t        // Map S value to pixel power\n\t\n\t    }, {\n\t        key: '_mapPixelPower',\n\t        value: function _mapPixelPower(value) {\n\t            return value * (this.realBeamRange.max - this.realBeamRange.min) / 255 + this.realBeamRange.min;\n\t        }\n\t\n\t        // Compute and return a command, return null if not changed\n\t\n\t    }, {\n\t        key: '_command',\n\t        value: function _command(name, value) {\n\t            // If the value argument is an object\n\t            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n\t                // Computed commands line\n\t                var commands = Array.prototype.slice.call(arguments);\n\t                var command = void 0,\n\t                    line = [];\n\t\n\t                // for each command\n\t                for (var i = 0, il = commands.length; i < il; i++) {\n\t                    command = this._command.apply(this, commands[i]);\n\t                    command && line.push(command);\n\t                }\n\t\n\t                // Return the line if not empty\n\t                return line.length ? line.join(' ') : null;\n\t            }\n\t\n\t            // Format the value\n\t            value = value.toFixed(this.precision[name] || 0);\n\t\n\t            // If the value was changed or if verbose mode on\n\t            if (this.verboseG || value !== this.lastCommands[name]) {\n\t                this.lastCommands[name] = value;\n\t                return name + value;\n\t            }\n\t\n\t            // No change\n\t            return null;\n\t        }\n\t\n\t        // Get a pixel power value from the canvas data grid\n\t\n\t    }, {\n\t        key: '_getPixelPower',\n\t        value: function _getPixelPower(x, y, defaultValue) {\n\t            try {\n\t                // Reverse Y value since canvas as top/left origin\n\t                y = this.size.height - y - 1;\n\t\n\t                // Get pixel info\n\t                var pixel = this.getPixel(x, y);\n\t\n\t                // Reversed gray value [ 0 = white | 255 = black ]\n\t                return 255 - pixel.gray;\n\t            } catch (error) {\n\t                if (arguments.length === 3) {\n\t                    return defaultValue;\n\t                }\n\t                throw error;\n\t            }\n\t        }\n\t\n\t        // Get a point from the current line with real world coordinates\n\t\n\t    }, {\n\t        key: '_getPoint',\n\t        value: function _getPoint(index) {\n\t            // Get the point object from the current line\n\t            var point = this.currentLine[index];\n\t\n\t            // No point\n\t            if (!point) {\n\t                return null;\n\t            }\n\t\n\t            // Commands\n\t            point.G = point.s ? ['G', 1] : this.G0;\n\t            point.X = point.x * this.beamSize + this.offsets.X;\n\t            point.Y = point.y * this.beamSize + this.offsets.Y;\n\t            point.S = this._mapPixelPower(point.s);\n\t\n\t            // Offsets\n\t            if (this.diagonal) {\n\t                // Vertical offset\n\t                point.Y += this.beamSize;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                    point.Y -= this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                    point.Y += this.beamOffset;\n\t                }\n\t            } else {\n\t                // Vertical offset\n\t                point.Y += this.beamOffset;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                }\n\t            }\n\t\n\t            // Return the point\n\t            return point;\n\t        }\n\t\n\t        // Remove all trailing white spaces from the current line\n\t\n\t    }, {\n\t        key: '_trimCurrentLine',\n\t        value: function _trimCurrentLine() {\n\t            // Remove white spaces from the left\n\t            var point = this.currentLine[0];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.shift();\n\t                point = this.currentLine[0];\n\t            }\n\t\n\t            // Remove white spaces from the right\n\t            point = this.currentLine[this.currentLine.length - 2];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.pop();\n\t                point = this.currentLine[this.currentLine.length - 2];\n\t            }\n\t\n\t            // Return the new line length\n\t            return this.currentLine.length;\n\t        }\n\t\n\t        // Join pixel with same power\n\t\n\t    }, {\n\t        key: '_reduceCurrentLine',\n\t        value: function _reduceCurrentLine() {\n\t            // Line too short to be reduced\n\t            if (this.currentLine.length < 3) {\n\t                return this.currentLine.length;\n\t            }\n\t\n\t            // Extract all points exept the first one\n\t            var points = this.currentLine.splice(1);\n\t\n\t            // Get current power\n\t            var power = this.currentLine[0].p;\n\t\n\t            // For each extracted point\n\t            for (var point, i = 0, il = points.length - 1; i < il; i++) {\n\t                // Current point\n\t                point = points[i];\n\t\n\t                // On power change\n\t                if (power !== point.p) {\n\t                    this.currentLine.push(point);\n\t                }\n\t\n\t                // Update power\n\t                power = point.p;\n\t            }\n\t\n\t            // Add last point\n\t            this.currentLine.push(points[i]);\n\t        }\n\t\n\t        // Add extra white pixels at the ends\n\t\n\t    }, {\n\t        key: '_overscanCurrentLine',\n\t        value: function _overscanCurrentLine(reversed) {\n\t            // Number of pixels to add on each side\n\t            var pixels = this.overscan / this.ppm.x;\n\t\n\t            // Get first/last point\n\t            var firstPoint = this.currentLine[0];\n\t            var lastPoint = this.currentLine[this.currentLine.length - 1];\n\t\n\t            // Is last white/colored point ?\n\t            firstPoint.s && (firstPoint.lastWhite = true);\n\t            lastPoint.s && (lastPoint.lastColored = true);\n\t\n\t            // Reversed line ?\n\t            reversed ? lastPoint.s = 0 : firstPoint.s = 0;\n\t\n\t            // Create left/right points\n\t            var rightPoint = { x: lastPoint.x + pixels, y: lastPoint.y, s: 0, p: 0 };\n\t            var leftPoint = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 };\n\t\n\t            if (this.diagonal) {\n\t                leftPoint.y += pixels;\n\t                rightPoint.y -= pixels;\n\t            }\n\t\n\t            // Add left/right points to current line\n\t            this.currentLine.unshift(leftPoint);\n\t            this.currentLine.push(rightPoint);\n\t        }\n\t\n\t        // Process current line and return an array of GCode text lines\n\t\n\t    }, {\n\t        key: '_processCurrentLine',\n\t        value: function _processCurrentLine(reversed) {\n\t            // Trim trailing white spaces ?\n\t            if (this.trimLine && !this._trimCurrentLine()) {\n\t                // Skip empty line\n\t                return null;\n\t            }\n\t\n\t            // Join pixel with same power\n\t            if (this.joinPixel) {\n\t                this._reduceCurrentLine();\n\t            }\n\t\n\t            // Overscan ?\n\t            if (this.overscan) {\n\t                this._overscanCurrentLine(reversed);\n\t            }\n\t\n\t            // Mark first and last point on the current line\n\t            this.currentLine[0].first = true;\n\t            this.currentLine[this.currentLine.length - 1].last = true;\n\t\n\t            // Reversed line ?\n\t            if (reversed) {\n\t                this.currentLine = this.currentLine.reverse();\n\t            }\n\t\n\t            // Point index\n\t            var point = void 0,\n\t                index = 0;\n\t\n\t            // Init loop vars...\n\t            var command = void 0,\n\t                gcode = [];\n\t\n\t            // Get first point\n\t            point = this._getPoint(index);\n\t\n\t            // Move to start of the line\n\t            command = this._command(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0]);\n\t            command && gcode.push(command);\n\t\n\t            // For each point on the line\n\t            while (point) {\n\t                // Burn to next point\n\t                command = this._command(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S]);\n\t                command && gcode.push(command);\n\t\n\t                // Get next point\n\t                point = this._getPoint(++index);\n\t            }\n\t\n\t            // Return gcode commands array\n\t            if (gcode.length) {\n\t                return gcode;\n\t            }\n\t\n\t            // Empty line\n\t            return null;\n\t        }\n\t\n\t        // Parse horizontally\n\t\n\t    }, {\n\t        key: '_scanHorizontally',\n\t        value: function _scanHorizontally() {\n\t            var _this2 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine() {\n\t                // Reset current line\n\t                _this2.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // For each pixel on the line\n\t                for (x = 0; x <= w; x++) {\n\t                    // Get pixel power\n\t                    s = p = _this2._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add point to current line\n\t                    _this2.currentLine.push(point);\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this2._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(y / h * 100);\n\t                if (percent > lastPercent) {\n\t                    _this2._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this2.gcode.push.apply(_this2.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                computeCurrentLine();\n\t                processCurrentLine();\n\t\n\t                y++;\n\t\n\t                if (y < h) {\n\t                    if (_this2.nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    _this2._onDone({ gcode: _this2.gcode });\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t\n\t            // // For each image line\n\t            // for (y = 0; y < h; y++) {\n\t            //     processNextLine()\n\t            // }\n\t        }\n\t\n\t        // Parse diagonally\n\t\n\t    }, {\n\t        key: '_scanDiagonally',\n\t        value: function _scanDiagonally() {\n\t            var _this3 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var totalLines = w + h - 1;\n\t            var lineNum = 0;\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine(x, y) {\n\t                // Reset current line\n\t                _this3.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // Increment line num\n\t                lineNum++;\n\t\n\t                while (true) {\n\t                    // Y limit reached !\n\t                    if (y < -1 || y == h) {\n\t                        break;\n\t                    }\n\t\n\t                    // X limit reached !\n\t                    if (x < 0 || x > w) {\n\t                        break;\n\t                    }\n\t\n\t                    // Get pixel power\n\t                    s = p = _this3._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add the new point\n\t                    _this3.currentLine.push(point);\n\t\n\t                    // Next coords\n\t                    x++;\n\t                    y--;\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this3._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(lineNum / totalLines * 100);\n\t                if (percent > lastPercent) {\n\t                    _this3._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this3.gcode.push.apply(_this3.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                computeCurrentLine(x, y);\n\t                processCurrentLine();\n\t\n\t                if (!x) y++;else x++;\n\t\n\t                if (y === h) {\n\t                    x++;\n\t                    y--;\n\t                }\n\t\n\t                if (y < h && x < w) {\n\t                    if (_this3.nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    _this3._onDone({ gcode: _this3.gcode });\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t\n\t            // // For each image line\n\t            // for (y = 0; y < h; y++) {\n\t            //     scanDiagonalLine(x, y)\n\t            // }\n\t            //\n\t            // // For each image column (exept the first one)\n\t            // for (x = 1, y--; x < w; x++) {\n\t            //     scanDiagonalLine(x, y)\n\t            // }\n\t        }\n\t    }, {\n\t        key: '_onProgress',\n\t        value: function _onProgress(event) {\n\t            //console.log('progress:', event.percent);\n\t        }\n\t    }, {\n\t        key: '_onDone',\n\t        value: function _onDone(event) {\n\t            //console.log('done:', event.gcode.length);\n\t        }\n\t    }, {\n\t        key: 'on',\n\t        value: function on(event, callback, context) {\n\t            var _this4 = this;\n\t\n\t            var method = '_on' + event[0].toUpperCase() + event.slice(1);\n\t\n\t            if (!this[method] || typeof this[method] !== 'function') {\n\t                throw new Error('Undefined event: ' + event);\n\t            }\n\t\n\t            this[method] = function (event) {\n\t                return callback.call(context || _this4, event);\n\t            };\n\t\n\t            return this;\n\t        }\n\t    }]);\n\t\n\t    return RasterToGcode;\n\t}(_lw2.default);\n\t\n\t// Exports\n\t\n\t\n\texports.RasterToGcode = RasterToGcode;\n\texports.default = RasterToGcode;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(\"CanvasGrid\", [], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"CanvasGrid\"] = factory();\n\t\telse\n\t\t\troot[\"CanvasGrid\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t    value: true\n\t\t});\n\t\texports.CanvasGrid = undefined;\n\t\t\n\t\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\t\n\t\tvar _lw = __webpack_require__(2);\n\t\t\n\t\tvar _lw2 = _interopRequireDefault(_lw);\n\t\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\t\n\t\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\t\n\t\t// CanvasGrid class\n\t\tvar CanvasGrid = function () {\n\t\t    // Class constructor...\n\t\t    function CanvasGrid(settings) {\n\t\t        _classCallCheck(this, CanvasGrid);\n\t\t\n\t\t        // Init properties\n\t\t        this.cellSize = 1024;\n\t\t        this.scaleRatio = { x: 1, y: 1 };\n\t\t        this.filters = {};\n\t\t\n\t\t        Object.assign(this, settings || {});\n\t\t\n\t\t        if (!this.scaleRatio.x) {\n\t\t            this.scaleRatio = { x: this.scaleRatio, y: this.scaleRatio };\n\t\t        }\n\t\t\n\t\t        this.size = { width: 0, height: 0, cols: 0, rows: 0 };\n\t\t        this.file = null;\n\t\t        this.image = null;\n\t\t        this.url = null;\n\t\t        this.canvas = [];\n\t\t        this.pixels = [];\n\t\t    }\n\t\t\n\t\t    // <input> can be Image, File, URL object or URL string (http://* or data:image/*)\n\t\t\n\t\t\n\t\t    _createClass(CanvasGrid, [{\n\t\t        key: 'load',\n\t\t        value: function load(input) {\n\t\t            // Load File object\n\t\t            if (input instanceof File) {\n\t\t                return this.loadFromFile(input);\n\t\t            }\n\t\t\n\t\t            // Load Image object\n\t\t            if (input instanceof Image) {\n\t\t                return this.loadFromImage(input);\n\t\t            }\n\t\t\n\t\t            // Load URL object\n\t\t            if (typeof input === 'string' || input instanceof URL) {\n\t\t                return this.loadFromURL(input.trim());\n\t\t            }\n\t\t\n\t\t            // Return rejected promise with an Error object\n\t\t            return Promise.reject(new Error('Unsupported input format.'));\n\t\t        }\n\t\t\n\t\t        // Load image\n\t\t\n\t\t    }, {\n\t\t        key: '_loadImage',\n\t\t        value: function _loadImage(src, reject, resolve) {\n\t\t            var _this = this;\n\t\t\n\t\t            // Create Image object\n\t\t            var image = new Image();\n\t\t\n\t\t            // Register for load and error events\n\t\t            image.onload = function (event) {\n\t\t                _this.loadFromImage(image).then(resolve).catch(reject);\n\t\t            };\n\t\t\n\t\t            image.onerror = function (event) {\n\t\t                reject(new Error('An error occurred while loading the image : ' + src));\n\t\t            };\n\t\t\n\t\t            // Load the image from File url\n\t\t            image.src = src;\n\t\t        }\n\t\t\n\t\t        // Load from File object\n\t\t\n\t\t    }, {\n\t\t        key: 'loadFromFile',\n\t\t        value: function loadFromFile(input) {\n\t\t            var _this2 = this;\n\t\t\n\t\t            return new Promise(function (resolve, reject) {\n\t\t                // Bad input type\n\t\t                if (!(input instanceof File)) {\n\t\t                    reject(new Error('Input param must be a File object.'));\n\t\t                }\n\t\t\n\t\t                // Set input file\n\t\t                _this2.file = input;\n\t\t\n\t\t                // Load image\n\t\t                _this2._loadImage(URL.createObjectURL(input), reject, resolve);\n\t\t            });\n\t\t        }\n\t\t\n\t\t        // Load from URL object or string\n\t\t\n\t\t    }, {\n\t\t        key: 'loadFromURL',\n\t\t        value: function loadFromURL(input) {\n\t\t            var _this3 = this;\n\t\t\n\t\t            return new Promise(function (resolve, reject) {\n\t\t                // Bad input type\n\t\t                if (!(input instanceof URL) && typeof input !== 'string') {\n\t\t                    reject(new Error('Input param must be a URL string or object.'));\n\t\t                }\n\t\t\n\t\t                // Create url object\n\t\t                var url = input instanceof URL ? input : new URL(input);\n\t\t\n\t\t                // Set url\n\t\t                _this3.url = url;\n\t\t\n\t\t                // Load image\n\t\t                _this3._loadImage(url, reject, resolve);\n\t\t            });\n\t\t        }\n\t\t\n\t\t        // Load from Image object\n\t\t\n\t\t    }, {\n\t\t        key: 'loadFromImage',\n\t\t        value: function loadFromImage(input) {\n\t\t            var _this4 = this;\n\t\t\n\t\t            return new Promise(function (resolve, reject) {\n\t\t                // Bad input type\n\t\t                if (!(input instanceof Image)) {\n\t\t                    reject(new Error('Input param must be a Image object.'));\n\t\t                }\n\t\t\n\t\t                // Set input image\n\t\t                _this4.image = input;\n\t\t\n\t\t                // Process image\n\t\t                _this4._processImage();\n\t\t\n\t\t                // Resolve the promise\n\t\t                resolve(_this4);\n\t\t            });\n\t\t        }\n\t\t    }, {\n\t\t        key: '_processImage',\n\t\t        value: function _processImage() {\n\t\t            // Reset canvas grid\n\t\t            this.canvas = [];\n\t\t            this.pixels = [];\n\t\t\n\t\t            // Calculate grid size\n\t\t            var width = Math.round(this.image.width * this.scaleRatio.x);\n\t\t            var height = Math.round(this.image.height * this.scaleRatio.y);\n\t\t            var cols = Math.ceil(width / this.cellSize);\n\t\t            var rows = Math.ceil(height / this.cellSize);\n\t\t\n\t\t            this.size = { width: width, height: height, cols: cols, rows: rows };\n\t\t\n\t\t            // Create canvas grid\n\t\t            var line = null;\n\t\t            var canvas = null;\n\t\t            var context = null;\n\t\t\n\t\t            var x = null; // cols\n\t\t            var y = null; // rows\n\t\t            var sx = null; // scaled cols\n\t\t            var sy = null; // scaled rows\n\t\t            var sw = null; // scaled width\n\t\t            var sh = null; // scaled height\n\t\t\n\t\t            // For each line\n\t\t            for (y = 0; y < this.size.rows; y++) {\n\t\t                // Reset current line\n\t\t                line = [];\n\t\t\n\t\t                // For each column\n\t\t                for (x = 0; x < this.size.cols; x++) {\n\t\t                    // Create canvas element\n\t\t                    canvas = document.createElement('canvas');\n\t\t\n\t\t                    // Set canvas size\n\t\t                    if (x === 0 || x < this.size.cols - 1) {\n\t\t                        canvas.width = this.size.width < this.cellSize ? this.size.width : this.cellSize;\n\t\t                    } else {\n\t\t                        // Get the rest for the last item (except the first one)\n\t\t                        canvas.width = this.size.width % this.cellSize;\n\t\t                    }\n\t\t\n\t\t                    if (y === 0 || y < this.size.rows - 1) {\n\t\t                        canvas.height = this.size.height < this.cellSize ? this.size.height : this.cellSize;\n\t\t                    } else {\n\t\t                        // Get the rest for the last item (except the first one)\n\t\t                        canvas.height = this.size.height % this.cellSize;\n\t\t                    }\n\t\t\n\t\t                    // Get canvas 2d context\n\t\t                    context = canvas.getContext('2d');\n\t\t\n\t\t                    // Fill withe background (avoid alpha chanel calculation)\n\t\t                    context.fillStyle = 'white';\n\t\t                    context.fillRect(0, 0, canvas.width, canvas.height);\n\t\t\n\t\t                    // Draw the part of image in the canvas (scale)\n\t\t                    sw = canvas.width / this.scaleRatio.x;\n\t\t                    sh = canvas.height / this.scaleRatio.y;\n\t\t                    sx = x * this.cellSize / this.scaleRatio.x;\n\t\t                    sy = y * this.cellSize / this.scaleRatio.y;\n\t\t\n\t\t                    context.drawImage(this.image, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\n\t\t\n\t\t                    // Apply image filters\n\t\t                    (0, _lw2.default)(canvas, this.filters);\n\t\t\n\t\t                    // Add the canvas to current line\n\t\t                    line.push(canvas);\n\t\t                }\n\t\t\n\t\t                // Add the line to canvas grid\n\t\t                this.canvas.push(line);\n\t\t            }\n\t\t        }\n\t\t    }, {\n\t\t        key: 'getPixel',\n\t\t        value: function getPixel(x, y) {\n\t\t            // Test coords validity\n\t\t            x = parseInt(x);\n\t\t            y = parseInt(y);\n\t\t\n\t\t            if (isNaN(x) || isNaN(y)) {\n\t\t                throw new Error('[x, y] params must be Integer.');\n\t\t            }\n\t\t\n\t\t            // Test coords range\n\t\t            if (x < 0 || x >= this.size.width) {\n\t\t                throw new Error('Out of range: x = ' + x + ', max: ' + this.size.width);\n\t\t            }\n\t\t\n\t\t            if (y < 0 || y >= this.size.height) {\n\t\t                throw new Error('Out of range: y = ' + y + ', max: ' + this.size.height);\n\t\t            }\n\t\t\n\t\t            // Calculate target canvas coords\n\t\t            var col = parseInt(x / this.cellSize);\n\t\t            var row = parseInt(y / this.cellSize);\n\t\t\n\t\t            // Adjuste x/y values relative to canvas origin\n\t\t            col && (x -= this.cellSize * col);\n\t\t            row && (y -= this.cellSize * row);\n\t\t\n\t\t            // Get pixel data\n\t\t            var canvas = this.canvas[row][col];\n\t\t            var context = canvas.getContext('2d');\n\t\t            var pixelData = context.getImageData(x, y, 1, 1).data;\n\t\t\n\t\t            return {\n\t\t                color: { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] },\n\t\t                gray: (pixelData[0] + pixelData[1] + pixelData[2]) / 3,\n\t\t                grid: { col: col, row: row },\n\t\t                coords: { x: x, y: y }\n\t\t            };\n\t\t        }\n\t\t    }]);\n\t\t\n\t\t    return CanvasGrid;\n\t\t}();\n\t\t\n\t\t// Exports\n\t\t\n\t\t\n\t\texports.CanvasGrid = CanvasGrid;\n\t\texports.default = CanvasGrid;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\t\tif(true)\n\t\t\t\tmodule.exports = factory();\n\t\t\telse if(typeof define === 'function' && define.amd)\n\t\t\t\tdefine(\"CanvasFilter\", [], factory);\n\t\t\telse if(typeof exports === 'object')\n\t\t\t\texports[\"CanvasFilter\"] = factory();\n\t\t\telse\n\t\t\t\troot[\"CanvasFilter\"] = factory();\n\t\t})(this, function() {\n\t\treturn /******/ (function(modules) { // webpackBootstrap\n\t\t/******/ \t// The module cache\n\t\t/******/ \tvar installedModules = {};\n\t\t/******/\n\t\t/******/ \t// The require function\n\t\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\t/******/\n\t\t/******/ \t\t// Check if module is in cache\n\t\t/******/ \t\tif(installedModules[moduleId])\n\t\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\t/******/\n\t\t/******/ \t\t// Create a new module (and put it into the cache)\n\t\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t\t/******/ \t\t\texports: {},\n\t\t/******/ \t\t\tid: moduleId,\n\t\t/******/ \t\t\tloaded: false\n\t\t/******/ \t\t};\n\t\t/******/\n\t\t/******/ \t\t// Execute the module function\n\t\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t/******/\n\t\t/******/ \t\t// Flag the module as loaded\n\t\t/******/ \t\tmodule.loaded = true;\n\t\t/******/\n\t\t/******/ \t\t// Return the exports of the module\n\t\t/******/ \t\treturn module.exports;\n\t\t/******/ \t}\n\t\t/******/\n\t\t/******/\n\t\t/******/ \t// expose the modules object (__webpack_modules__)\n\t\t/******/ \t__webpack_require__.m = modules;\n\t\t/******/\n\t\t/******/ \t// expose the module cache\n\t\t/******/ \t__webpack_require__.c = installedModules;\n\t\t/******/\n\t\t/******/ \t// __webpack_public_path__\n\t\t/******/ \t__webpack_require__.p = \"\";\n\t\t/******/\n\t\t/******/ \t// Load entry module and return exports\n\t\t/******/ \treturn __webpack_require__(0);\n\t\t/******/ })\n\t\t/************************************************************************/\n\t\t/******/ ([\n\t\t/* 0 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\tmodule.exports = __webpack_require__(1);\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 1 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t'use strict';\n\t\t\t\n\t\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\t    value: true\n\t\t\t});\n\t\t\t// Grayscale algorithms\n\t\t\tvar grayscaleAlgorithms = ['none', 'average', 'desaturation', 'decomposition-min', 'decomposition-max', 'luma', 'luma-601', 'luma-709', 'luma-240', 'red-chanel', 'green-chanel', 'blue-chanel'];\n\t\t\t\n\t\t\t// Trucate color value in the 0-255 range\n\t\t\tfunction color(color) {\n\t\t\t    return color < 0 ? 0 : color > 255 ? 255 : color;\n\t\t\t}\n\t\t\t\n\t\t\t// Filters ...\n\t\t\tfunction brightness(data, i, value) {\n\t\t\t    if (value !== undefined) {\n\t\t\t        data[i] = color(data[i] + value);\n\t\t\t        data[i + 1] = color(data[i + 1] + value);\n\t\t\t        data[i + 2] = color(data[i + 2] + value);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction contrast(data, i, value) {\n\t\t\t    if (value !== undefined) {\n\t\t\t        data[i] = color(value * (data[i] - 128) + 128);\n\t\t\t        data[i + 1] = color(value * (data[i + 1] - 128) + 128);\n\t\t\t        data[i + 2] = color(value * (data[i + 2] - 128) + 128);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction gamma(data, i, value) {\n\t\t\t    if (value !== undefined) {\n\t\t\t        data[i] = color(Math.exp(Math.log(255 * (data[i] / 255)) * value));\n\t\t\t        data[i + 1] = color(Math.exp(Math.log(255 * (data[i + 1] / 255)) * value));\n\t\t\t        data[i + 2] = color(Math.exp(Math.log(255 * (data[i + 2] / 255)) * value));\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction grayscale(data, i, algorithm, shades) {\n\t\t\t    // Graysale\n\t\t\t    // http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\n\t\t\t\n\t\t\t    // Unsupported algorithm\n\t\t\t    if (grayscaleAlgorithms.indexOf(algorithm) === -1) {\n\t\t\t        throw new Error('Unsupported grayscale algorithm: ' + algorithm);\n\t\t\t    }\n\t\t\t\n\t\t\t    // None\n\t\t\t    if (algorithm === 'none') {\n\t\t\t        return null;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Get Red/Green/Blue values\n\t\t\t    var gray = void 0;\n\t\t\t    var r = data[i];\n\t\t\t    var g = data[i + 1];\n\t\t\t    var b = data[i + 2];\n\t\t\t\n\t\t\t    switch (algorithm) {\n\t\t\t        case 'average':\n\t\t\t            gray = (r + g + b) / 3;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma':\n\t\t\t            // Default\n\t\t\t            gray = r * 0.3 + g * 0.59 + b * 0.11;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma-601':\n\t\t\t            // CCIR-601\n\t\t\t            gray = r * 0.299 + g * 0.587 + b * 0.114;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma-709':\n\t\t\t            // ITU-R-709\n\t\t\t            gray = r * 0.2126 + g * 0.7152 + b * 0.0722;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma-240':\n\t\t\t            // SMPTE-240M\n\t\t\t            gray = r * 0.212 + g * 0.701 + b * 0.087;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'desaturation':\n\t\t\t            gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'decomposition-min':\n\t\t\t            gray = Math.min(r, g, b);\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'decomposition-max':\n\t\t\t            gray = Math.max(r, g, b);\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'red-chanel':\n\t\t\t            gray = r;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'green-chanel':\n\t\t\t            gray = g;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'blue-chanel':\n\t\t\t            gray = b;\n\t\t\t            break;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Shades of gray\n\t\t\t    if (shades !== undefined) {\n\t\t\t        gray = parseInt(gray / shades) * shades;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Force integer\n\t\t\t    gray = parseInt(gray);\n\t\t\t\n\t\t\t    // Set new r/g/b values\n\t\t\t    data[i] = color(gray);\n\t\t\t    data[i + 1] = color(gray);\n\t\t\t    data[i + 2] = color(gray);\n\t\t\t}\n\t\t\t\n\t\t\t// Apply filters on provided canvas\n\t\t\tfunction canvasFilters(canvas, settings) {\n\t\t\t    settings = Object.assign({}, {\n\t\t\t        smoothing: false, // Smoothing [true|fale]\n\t\t\t        brightness: 0, // Image brightness [-255 to +255]\n\t\t\t        contrast: 0, // Image contrast [-255 to +255]\n\t\t\t        gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t\t\t        grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t\t\t        shadesOfGray: 256 // Number of shades of gray [2-256]\n\t\t\t    }, settings || {});\n\t\t\t\n\t\t\t    // Get canvas 2d context\n\t\t\t    var context = canvas.getContext('2d');\n\t\t\t\n\t\t\t    // Smoothing\n\t\t\t    if (context.imageSmoothingEnabled !== undefined) {\n\t\t\t        context.imageSmoothingEnabled = settings.smoothing;\n\t\t\t    } else {\n\t\t\t        context.mozImageSmoothingEnabled = settings.smoothing;\n\t\t\t        context.webkitImageSmoothingEnabled = settings.smoothing;\n\t\t\t        context.msImageSmoothingEnabled = settings.smoothing;\n\t\t\t        context.oImageSmoothingEnabled = settings.smoothing;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Get image data\n\t\t\t    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\t\t\t    var data = imageData.data;\n\t\t\t\n\t\t\t    var contrastFactor = void 0,\n\t\t\t        brightnessOffset = void 0,\n\t\t\t        gammaCorrection = void 0,\n\t\t\t        shadesOfGrayFactor = void 0;\n\t\t\t\n\t\t\t    if (settings.contrast !== 0) {\n\t\t\t        contrastFactor = 259 * (settings.contrast + 255) / (255 * (259 - settings.contrast));\n\t\t\t    }\n\t\t\t\n\t\t\t    if (settings.brightness !== 0) {\n\t\t\t        brightnessOffset = settings.brightness;\n\t\t\t    }\n\t\t\t\n\t\t\t    if (settings.gamma !== 0) {\n\t\t\t        gammaCorrection = 1 / settings.gamma;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Shades of gray\n\t\t\t    if (settings.shadesOfGray > 1 && settings.shadesOfGray < 256) {\n\t\t\t        shadesOfGrayFactor = 255 / (settings.shadesOfGray - 1);\n\t\t\t    }\n\t\t\t\n\t\t\t    // For each pixel\n\t\t\t    for (var i = 0, il = data.length; i < il; i += 4) {\n\t\t\t        // Apply filters\n\t\t\t        brightness(data, i, brightnessOffset);\n\t\t\t        contrast(data, i, contrastFactor);\n\t\t\t        gamma(data, i, gammaCorrection);\n\t\t\t        grayscale(data, i, settings.grayscale, shadesOfGrayFactor);\n\t\t\t    }\n\t\t\t\n\t\t\t    // Write new image data on the context\n\t\t\t    context.putImageData(imageData, 0, 0);\n\t\t\t}\n\t\t\t\n\t\t\t// Exports\n\t\t\texports.canvasFilters = canvasFilters;\n\t\t\texports.default = canvasFilters;\n\t\t\n\t\t/***/ }\n\t\t/******/ ])\n\t\t});\n\t\t;\n\t\t//# sourceMappingURL=lw.canvas-filters.js.map\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=lw.canvas-grid.js.map\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.raster-to-gcode.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0ec33232458f80da9da6","import CanvasGrid from 'lw.canvas-grid'\n\n// RasterToGcode class\nclass RasterToGcode extends CanvasGrid {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = Object.assign({\n            ppi: { x: 254, y: 254 }, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\n            beamSize : 0.1,                  // Beam size in millimeters\n            beamRange: { min: 0, max: 1 },   // Beam power range (Firmware value)\n            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n            feedRate : 1500,                 // Feed rate in mm/min (F value)\n            feedUnit : 'mm/min',             // Feed rate unit [mm/min, mm/sec]\n\n            offsets  : { X: 0, Y: 0 }, // Global coordinates offsets\n            trimLine : true,           // Trim trailing white pixels\n            joinPixel: true,           // Join consecutive pixels with same intensity\n            burnWhite: true,           // [true = G1 S0 | false = G0] on inner white pixels\n            verboseG : false,          // Output verbose GCode (print each commands)\n            diagonal : false,          // Go diagonally (increase the distance between points)\n\n            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\n            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\n            filters: {\n                smoothing   : 0,      // Smoothing the input image ?\n                brightness  : 0,      // Image brightness [-255 to +255]\n                contrast    : 0,      // Image contrast [-255 to +255]\n                gamma       : 0,      // Image gamma correction [0.01 to 7.99]\n                grayscale   : 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n                shadesOfGray: 256     // Number of shades of gray [2-256]\n            },\n\n            progress       : null, // On progress callbacks\n            progressContext: null, // On progress callback context\n\n            done       : null, // On done callback\n            doneContext: null  // On done callback context\n        }, settings || {})\n\n        // Init properties\n        super(settings)\n\n        // Uniforme ppi\n        if (! this.ppi.x) {\n            this.ppi = { x: this.ppi, y: this.ppi }\n        }\n\n        // Calculate PPM = Pixel Per Millimeters\n        // this.ppm = 2540 / (this.ppi * 100)\n        // this.ppm = parseFloat(this.ppm.toFixed(10))\n        this.ppm = {\n            x: parseFloat((2540 / (this.ppi.x * 100)).toFixed(10)),\n            y: parseFloat((2540 / (this.ppi.y * 100)).toFixed(10))\n        }\n\n        // Calculate scale ratio\n        this.scaleRatio = {\n            x: this.ppm.x / this.beamSize,\n            y: this.ppm.y / this.beamSize\n        }\n\n        // State...\n        this.gcode        = null\n        this.currentLine  = null\n        this.lastCommands = null\n\n        // Output size in millimeters\n        this.outputSize = { width : 0, height: 0 }\n\n        // G0 command\n        this.G1 = ['G', 1]\n        this.G0 = ['G', this.burnWhite ? 1 : 0]\n\n        // Calculate beam offset\n        this.beamOffset = this.beamSize * 1000 / 2000\n\n        // Calculate real beam range\n        this.realBeamRange = {\n            min: this.beamRange.max / 100 * this.beamPower.min,\n            max: this.beamRange.max / 100 * this.beamPower.max\n        }\n\n        // Adjuste feed rate to mm/min\n        if (this.feedUnit === 'mm/sec') {\n            this.feedRate *= 60\n        }\n\n        // register user callbacks\n        this.progress && this.on('progress', this.progress, this.progressContext)\n        this.done && this.on('done', this.done, this.doneContext)\n    }\n\n    // Process image\n    _processImage() {\n        // Call parent method\n        super._processImage()\n\n        // Calculate output size\n        this.outputSize = {\n            width : this.size.width  * (this.beamSize * 1000) / 1000,\n            height: this.size.height * (this.beamSize * 1000) / 1000\n        }\n    }\n\n    // Process image and return gcode string\n    run(progress, done) {\n        // Reset state\n        this.gcode        = []\n        this.lastCommands = {}\n        this.currentLine  = null\n\n        // register user callbacks\n        progress && this.on('progress', progress)\n        done && this.on('done', done)\n\n        // Add gcode header\n        this._addHeader()\n\n        // Scan type ?\n        if (this.diagonal) {\n            this._scanDiagonally()\n        }\n        else {\n            this._scanHorizontally()\n        }\n\n        if (! this.nonBlocking) {\n            return this.gcode\n        }\n    }\n\n    _addHeader() {\n        // Base headers\n        this.gcode.push(\n            '; Generated by LaserWeb (lw.raster-to-gcode.js)',\n            '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm',\n            '; PPI        : x: ' + this.ppi.x + ' - y: ' + this.ppi.y,\n            '; PPM        : x: ' + this.ppm.x + ' - y: ' + this.ppm.y,\n            '; Beam size  : ' + this.beamSize + ' mm',\n            '; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max,\n            '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %',\n            '; Feed rate  : ' + this.feedRate + ' mm/min'\n        )\n\n        // Print activated options\n        let options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal']\n\n        for (var i = options.length - 1; i >= 0; i--) {\n            if (! this[options[i]]) {\n                options.splice(i, 1)\n            }\n        }\n\n        if (options.length) {\n            this.gcode.push('; Options    : ' + options.join(', '))\n        }\n\n        // Set feed rates\n        this.gcode.push(\n            '',\n            'G0 F' + this.feedRate,\n            'G1 F' + this.feedRate,\n            ''\n        )\n    }\n\n    // Map S value to pixel power\n    _mapPixelPower(value) {\n        return value * (this.realBeamRange.max - this.realBeamRange.min)\n                     / 255 + this.realBeamRange.min\n    }\n\n    // Compute and return a command, return null if not changed\n    _command(name, value) {\n        // If the value argument is an object\n        if (typeof value === 'object') {\n            // Computed commands line\n            let commands = Array.prototype.slice.call(arguments)\n            let command, line = []\n\n            // for each command\n            for (var i = 0, il = commands.length; i < il; i++) {\n                command = this._command.apply(this, commands[i])\n                command && line.push(command)\n            }\n\n            // Return the line if not empty\n            return line.length ? line.join(' ') : null\n        }\n\n        // Format the value\n        value = value.toFixed(this.precision[name] || 0)\n\n        // If the value was changed or if verbose mode on\n        if (this.verboseG || value !== this.lastCommands[name]) {\n            this.lastCommands[name] = value\n            return name + value\n        }\n\n        // No change\n        return null\n    }\n\n    // Get a pixel power value from the canvas data grid\n    _getPixelPower(x, y, defaultValue) {\n        try {\n            // Reverse Y value since canvas as top/left origin\n            y = this.size.height - y - 1;\n\n            // Get pixel info\n            let pixel = this.getPixel(x, y)\n\n            // Reversed gray value [ 0 = white | 255 = black ]\n            return 255 - pixel.gray\n        }\n        catch (error) {\n            if (arguments.length === 3) {\n                return defaultValue\n            }\n            throw error\n        }\n    }\n\n    // Get a point from the current line with real world coordinates\n    _getPoint(index) {\n        // Get the point object from the current line\n        let point = this.currentLine[index]\n\n        // No point\n        if (! point) {\n            return null\n        }\n\n        // Commands\n        point.G = point.s ? ['G', 1] : this.G0\n        point.X = (point.x * this.beamSize) + this.offsets.X\n        point.Y = (point.y * this.beamSize) + this.offsets.Y\n        point.S = this._mapPixelPower(point.s)\n\n        // Offsets\n        if (this.diagonal) {\n            // Vertical offset\n            point.Y += this.beamSize\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n                point.Y -= this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n                point.Y += this.beamOffset\n            }\n        }\n        else {\n            // Vertical offset\n            point.Y += this.beamOffset\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n            }\n        }\n\n        // Return the point\n        return point\n    }\n\n    // Remove all trailing white spaces from the current line\n    _trimCurrentLine() {\n        // Remove white spaces from the left\n        let point = this.currentLine[0]\n\n        while (point && ! point.p) {\n            this.currentLine.shift()\n            point = this.currentLine[0]\n        }\n\n        // Remove white spaces from the right\n        point = this.currentLine[this.currentLine.length - 2]\n\n        while (point && ! point.p) {\n            this.currentLine.pop()\n            point = this.currentLine[this.currentLine.length - 2]\n        }\n\n        // Return the new line length\n        return this.currentLine.length\n    }\n\n    // Join pixel with same power\n    _reduceCurrentLine() {\n        // Line too short to be reduced\n        if (this.currentLine.length < 3) {\n            return this.currentLine.length\n        }\n\n        // Extract all points exept the first one\n        let points = this.currentLine.splice(1)\n\n        // Get current power\n        let power = this.currentLine[0].p\n\n        // For each extracted point\n        for (var point, i = 0, il = points.length - 1; i < il; i++) {\n            // Current point\n            point = points[i]\n\n            // On power change\n            if (power !== point.p) {\n                this.currentLine.push(point)\n            }\n\n            // Update power\n            power = point.p\n        }\n\n        // Add last point\n        this.currentLine.push(points[i])\n    }\n\n    // Add extra white pixels at the ends\n    _overscanCurrentLine(reversed) {\n        // Number of pixels to add on each side\n        let pixels = this.overscan / this.ppm.x\n\n        // Get first/last point\n        let firstPoint = this.currentLine[0]\n        let lastPoint  = this.currentLine[this.currentLine.length - 1]\n\n        // Is last white/colored point ?\n        firstPoint.s && (firstPoint.lastWhite  = true)\n        lastPoint.s  && (lastPoint.lastColored = true)\n\n        // Reversed line ?\n        reversed ? (lastPoint.s = 0) : (firstPoint.s = 0)\n\n        // Create left/right points\n        let rightPoint = { x: lastPoint.x + pixels , y: lastPoint.y , s: 0, p: 0 }\n        let leftPoint  = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 }\n\n        if (this.diagonal) {\n            leftPoint.y  += pixels\n            rightPoint.y -= pixels\n        }\n\n        // Add left/right points to current line\n        this.currentLine.unshift(leftPoint)\n        this.currentLine.push(rightPoint)\n    }\n\n    // Process current line and return an array of GCode text lines\n    _processCurrentLine(reversed) {\n        // Trim trailing white spaces ?\n        if (this.trimLine && ! this._trimCurrentLine()) {\n            // Skip empty line\n            return null\n        }\n\n        // Join pixel with same power\n        if (this.joinPixel) {\n            this._reduceCurrentLine()\n        }\n\n        // Overscan ?\n        if (this.overscan) {\n            this._overscanCurrentLine(reversed)\n        }\n\n        // Mark first and last point on the current line\n        this.currentLine[0].first = true\n        this.currentLine[this.currentLine.length - 1].last = true\n\n        // Reversed line ?\n        if (reversed) {\n            this.currentLine = this.currentLine.reverse()\n        }\n\n        // Point index\n        let point, index = 0\n\n        // Init loop vars...\n        let command, gcode = []\n\n        // Get first point\n        point = this._getPoint(index)\n\n        // Move to start of the line\n        command = this._command(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0])\n        command && gcode.push(command)\n\n        // For each point on the line\n        while (point) {\n            // Burn to next point\n            command = this._command(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S])\n            command && gcode.push(command)\n\n            // Get next point\n            point = this._getPoint(++index)\n        }\n\n        // Return gcode commands array\n        if (gcode.length) {\n            return gcode\n        }\n\n        // Empty line\n        return null\n    }\n\n    // Parse horizontally\n    _scanHorizontally() {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = () => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // For each pixel on the line\n            for (x = 0; x <= w; x++) {\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && ! point.p && p\n                lastColored = point && point.p && ! p\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add point to current line\n                this.currentLine.push(point)\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((y / h) * 100)\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            computeCurrentLine()\n            processCurrentLine()\n\n            y++\n\n            if (y < h) {\n                if (this.nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                this._onDone({ gcode: this.gcode })\n            }\n        }\n\n        processNextLine()\n\n        // // For each image line\n        // for (y = 0; y < h; y++) {\n        //     processNextLine()\n        // }\n    }\n\n    // Parse diagonally\n    _scanDiagonally() {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let totalLines  = w + h - 1\n        let lineNum     = 0\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = (x, y) => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // Increment line num\n            lineNum++\n\n            while(true) {\n                // Y limit reached !\n                if (y < -1 || y == h) {\n                    break\n                }\n\n                // X limit reached !\n                if (x < 0 || x > w) {\n                    break\n                }\n\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && (! point.p && p)\n                lastColored = point && (point.p && ! p)\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add the new point\n                this.currentLine.push(point)\n\n                // Next coords\n                x++\n                y--\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((lineNum / totalLines) * 100)\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            computeCurrentLine(x, y)\n            processCurrentLine()\n\n            if (! x) y++\n            else x++\n\n            if (y === h) {\n                x++\n                y--\n            }\n\n            if (y < h && x < w) {\n                if (this.nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                this._onDone({ gcode: this.gcode })\n            }\n        }\n\n        processNextLine()\n\n        // // For each image line\n        // for (y = 0; y < h; y++) {\n        //     scanDiagonalLine(x, y)\n        // }\n        //\n        // // For each image column (exept the first one)\n        // for (x = 1, y--; x < w; x++) {\n        //     scanDiagonalLine(x, y)\n        // }\n    }\n\n    _onProgress(event) {\n        //console.log('progress:', event.percent);\n    }\n\n    _onDone(event) {\n        //console.log('done:', event.gcode.length);\n    }\n\n    on(event, callback, context) {\n        let method = '_on' + event[0].toUpperCase() + event.slice(1)\n\n        if (! this[method] || typeof this[method] !== 'function') {\n            throw new Error('Undefined event: ' + event)\n        }\n\n        this[method] = event => callback.call(context || this, event)\n\n        return this\n    }\n}\n\n// Exports\nexport { RasterToGcode }\nexport default RasterToGcode\n\n\n\n// WEBPACK FOOTER //\n// ./raster-to-gcode.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"CanvasGrid\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CanvasGrid\"] = factory();\n\telse\n\t\troot[\"CanvasGrid\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.CanvasGrid = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _lw = __webpack_require__(2);\n\t\n\tvar _lw2 = _interopRequireDefault(_lw);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// CanvasGrid class\n\tvar CanvasGrid = function () {\n\t    // Class constructor...\n\t    function CanvasGrid(settings) {\n\t        _classCallCheck(this, CanvasGrid);\n\t\n\t        // Init properties\n\t        this.cellSize = 1024;\n\t        this.scaleRatio = { x: 1, y: 1 };\n\t        this.filters = {};\n\t\n\t        Object.assign(this, settings || {});\n\t\n\t        if (!this.scaleRatio.x) {\n\t            this.scaleRatio = { x: this.scaleRatio, y: this.scaleRatio };\n\t        }\n\t\n\t        this.size = { width: 0, height: 0, cols: 0, rows: 0 };\n\t        this.file = null;\n\t        this.image = null;\n\t        this.url = null;\n\t        this.canvas = [];\n\t        this.pixels = [];\n\t    }\n\t\n\t    // <input> can be Image, File, URL object or URL string (http://* or data:image/*)\n\t\n\t\n\t    _createClass(CanvasGrid, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load Image object\n\t            if (input instanceof Image) {\n\t                return this.loadFromImage(input);\n\t            }\n\t\n\t            // Load URL object\n\t            if (typeof input === 'string' || input instanceof URL) {\n\t                return this.loadFromURL(input.trim());\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load image\n\t\n\t    }, {\n\t        key: '_loadImage',\n\t        value: function _loadImage(src, reject, resolve) {\n\t            var _this = this;\n\t\n\t            // Create Image object\n\t            var image = new Image();\n\t\n\t            // Register for load and error events\n\t            image.onload = function (event) {\n\t                _this.loadFromImage(image).then(resolve).catch(reject);\n\t            };\n\t\n\t            image.onerror = function (event) {\n\t                reject(new Error('An error occurred while loading the image : ' + src));\n\t            };\n\t\n\t            // Load the image from File url\n\t            image.src = src;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Set input file\n\t                _this2.file = input;\n\t\n\t                // Load image\n\t                _this2._loadImage(URL.createObjectURL(input), reject, resolve);\n\t            });\n\t        }\n\t\n\t        // Load from URL object or string\n\t\n\t    }, {\n\t        key: 'loadFromURL',\n\t        value: function loadFromURL(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof URL) && typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a URL string or object.'));\n\t                }\n\t\n\t                // Create url object\n\t                var url = input instanceof URL ? input : new URL(input);\n\t\n\t                // Set url\n\t                _this3.url = url;\n\t\n\t                // Load image\n\t                _this3._loadImage(url, reject, resolve);\n\t            });\n\t        }\n\t\n\t        // Load from Image object\n\t\n\t    }, {\n\t        key: 'loadFromImage',\n\t        value: function loadFromImage(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Image)) {\n\t                    reject(new Error('Input param must be a Image object.'));\n\t                }\n\t\n\t                // Set input image\n\t                _this4.image = input;\n\t\n\t                // Process image\n\t                _this4._processImage();\n\t\n\t                // Resolve the promise\n\t                resolve(_this4);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_processImage',\n\t        value: function _processImage() {\n\t            // Reset canvas grid\n\t            this.canvas = [];\n\t            this.pixels = [];\n\t\n\t            // Calculate grid size\n\t            var width = Math.round(this.image.width * this.scaleRatio.x);\n\t            var height = Math.round(this.image.height * this.scaleRatio.y);\n\t            var cols = Math.ceil(width / this.cellSize);\n\t            var rows = Math.ceil(height / this.cellSize);\n\t\n\t            this.size = { width: width, height: height, cols: cols, rows: rows };\n\t\n\t            // Create canvas grid\n\t            var line = null;\n\t            var canvas = null;\n\t            var context = null;\n\t\n\t            var x = null; // cols\n\t            var y = null; // rows\n\t            var sx = null; // scaled cols\n\t            var sy = null; // scaled rows\n\t            var sw = null; // scaled width\n\t            var sh = null; // scaled height\n\t\n\t            // For each line\n\t            for (y = 0; y < this.size.rows; y++) {\n\t                // Reset current line\n\t                line = [];\n\t\n\t                // For each column\n\t                for (x = 0; x < this.size.cols; x++) {\n\t                    // Create canvas element\n\t                    canvas = document.createElement('canvas');\n\t\n\t                    // Set canvas size\n\t                    if (x === 0 || x < this.size.cols - 1) {\n\t                        canvas.width = this.size.width < this.cellSize ? this.size.width : this.cellSize;\n\t                    } else {\n\t                        // Get the rest for the last item (except the first one)\n\t                        canvas.width = this.size.width % this.cellSize;\n\t                    }\n\t\n\t                    if (y === 0 || y < this.size.rows - 1) {\n\t                        canvas.height = this.size.height < this.cellSize ? this.size.height : this.cellSize;\n\t                    } else {\n\t                        // Get the rest for the last item (except the first one)\n\t                        canvas.height = this.size.height % this.cellSize;\n\t                    }\n\t\n\t                    // Get canvas 2d context\n\t                    context = canvas.getContext('2d');\n\t\n\t                    // Fill withe background (avoid alpha chanel calculation)\n\t                    context.fillStyle = 'white';\n\t                    context.fillRect(0, 0, canvas.width, canvas.height);\n\t\n\t                    // Draw the part of image in the canvas (scale)\n\t                    sw = canvas.width / this.scaleRatio.x;\n\t                    sh = canvas.height / this.scaleRatio.y;\n\t                    sx = x * this.cellSize / this.scaleRatio.x;\n\t                    sy = y * this.cellSize / this.scaleRatio.y;\n\t\n\t                    context.drawImage(this.image, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\n\t\n\t                    // Apply image filters\n\t                    (0, _lw2.default)(canvas, this.filters);\n\t\n\t                    // Add the canvas to current line\n\t                    line.push(canvas);\n\t                }\n\t\n\t                // Add the line to canvas grid\n\t                this.canvas.push(line);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getPixel',\n\t        value: function getPixel(x, y) {\n\t            // Test coords validity\n\t            x = parseInt(x);\n\t            y = parseInt(y);\n\t\n\t            if (isNaN(x) || isNaN(y)) {\n\t                throw new Error('[x, y] params must be Integer.');\n\t            }\n\t\n\t            // Test coords range\n\t            if (x < 0 || x >= this.size.width) {\n\t                throw new Error('Out of range: x = ' + x + ', max: ' + this.size.width);\n\t            }\n\t\n\t            if (y < 0 || y >= this.size.height) {\n\t                throw new Error('Out of range: y = ' + y + ', max: ' + this.size.height);\n\t            }\n\t\n\t            // Calculate target canvas coords\n\t            var col = parseInt(x / this.cellSize);\n\t            var row = parseInt(y / this.cellSize);\n\t\n\t            // Adjuste x/y values relative to canvas origin\n\t            col && (x -= this.cellSize * col);\n\t            row && (y -= this.cellSize * row);\n\t\n\t            // Get pixel data\n\t            var canvas = this.canvas[row][col];\n\t            var context = canvas.getContext('2d');\n\t            var pixelData = context.getImageData(x, y, 1, 1).data;\n\t\n\t            return {\n\t                color: { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] },\n\t                gray: (pixelData[0] + pixelData[1] + pixelData[2]) / 3,\n\t                grid: { col: col, row: row },\n\t                coords: { x: x, y: y }\n\t            };\n\t        }\n\t    }]);\n\t\n\t    return CanvasGrid;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.CanvasGrid = CanvasGrid;\n\texports.default = CanvasGrid;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(\"CanvasFilter\", [], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"CanvasFilter\"] = factory();\n\t\telse\n\t\t\troot[\"CanvasFilter\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t    value: true\n\t\t});\n\t\t// Grayscale algorithms\n\t\tvar grayscaleAlgorithms = ['none', 'average', 'desaturation', 'decomposition-min', 'decomposition-max', 'luma', 'luma-601', 'luma-709', 'luma-240', 'red-chanel', 'green-chanel', 'blue-chanel'];\n\t\t\n\t\t// Trucate color value in the 0-255 range\n\t\tfunction color(color) {\n\t\t    return color < 0 ? 0 : color > 255 ? 255 : color;\n\t\t}\n\t\t\n\t\t// Filters ...\n\t\tfunction brightness(data, i, value) {\n\t\t    if (value !== undefined) {\n\t\t        data[i] = color(data[i] + value);\n\t\t        data[i + 1] = color(data[i + 1] + value);\n\t\t        data[i + 2] = color(data[i + 2] + value);\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction contrast(data, i, value) {\n\t\t    if (value !== undefined) {\n\t\t        data[i] = color(value * (data[i] - 128) + 128);\n\t\t        data[i + 1] = color(value * (data[i + 1] - 128) + 128);\n\t\t        data[i + 2] = color(value * (data[i + 2] - 128) + 128);\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction gamma(data, i, value) {\n\t\t    if (value !== undefined) {\n\t\t        data[i] = color(Math.exp(Math.log(255 * (data[i] / 255)) * value));\n\t\t        data[i + 1] = color(Math.exp(Math.log(255 * (data[i + 1] / 255)) * value));\n\t\t        data[i + 2] = color(Math.exp(Math.log(255 * (data[i + 2] / 255)) * value));\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction grayscale(data, i, algorithm, shades) {\n\t\t    // Graysale\n\t\t    // http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\n\t\t\n\t\t    // Unsupported algorithm\n\t\t    if (grayscaleAlgorithms.indexOf(algorithm) === -1) {\n\t\t        throw new Error('Unsupported grayscale algorithm: ' + algorithm);\n\t\t    }\n\t\t\n\t\t    // None\n\t\t    if (algorithm === 'none') {\n\t\t        return null;\n\t\t    }\n\t\t\n\t\t    // Get Red/Green/Blue values\n\t\t    var gray = void 0;\n\t\t    var r = data[i];\n\t\t    var g = data[i + 1];\n\t\t    var b = data[i + 2];\n\t\t\n\t\t    switch (algorithm) {\n\t\t        case 'average':\n\t\t            gray = (r + g + b) / 3;\n\t\t            break;\n\t\t\n\t\t        case 'luma':\n\t\t            // Default\n\t\t            gray = r * 0.3 + g * 0.59 + b * 0.11;\n\t\t            break;\n\t\t\n\t\t        case 'luma-601':\n\t\t            // CCIR-601\n\t\t            gray = r * 0.299 + g * 0.587 + b * 0.114;\n\t\t            break;\n\t\t\n\t\t        case 'luma-709':\n\t\t            // ITU-R-709\n\t\t            gray = r * 0.2126 + g * 0.7152 + b * 0.0722;\n\t\t            break;\n\t\t\n\t\t        case 'luma-240':\n\t\t            // SMPTE-240M\n\t\t            gray = r * 0.212 + g * 0.701 + b * 0.087;\n\t\t            break;\n\t\t\n\t\t        case 'desaturation':\n\t\t            gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n\t\t            break;\n\t\t\n\t\t        case 'decomposition-min':\n\t\t            gray = Math.min(r, g, b);\n\t\t            break;\n\t\t\n\t\t        case 'decomposition-max':\n\t\t            gray = Math.max(r, g, b);\n\t\t            break;\n\t\t\n\t\t        case 'red-chanel':\n\t\t            gray = r;\n\t\t            break;\n\t\t\n\t\t        case 'green-chanel':\n\t\t            gray = g;\n\t\t            break;\n\t\t\n\t\t        case 'blue-chanel':\n\t\t            gray = b;\n\t\t            break;\n\t\t    }\n\t\t\n\t\t    // Shades of gray\n\t\t    if (shades !== undefined) {\n\t\t        gray = parseInt(gray / shades) * shades;\n\t\t    }\n\t\t\n\t\t    // Force integer\n\t\t    gray = parseInt(gray);\n\t\t\n\t\t    // Set new r/g/b values\n\t\t    data[i] = color(gray);\n\t\t    data[i + 1] = color(gray);\n\t\t    data[i + 2] = color(gray);\n\t\t}\n\t\t\n\t\t// Apply filters on provided canvas\n\t\tfunction canvasFilters(canvas, settings) {\n\t\t    settings = Object.assign({}, {\n\t\t        smoothing: false, // Smoothing [true|fale]\n\t\t        brightness: 0, // Image brightness [-255 to +255]\n\t\t        contrast: 0, // Image contrast [-255 to +255]\n\t\t        gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t\t        grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t\t        shadesOfGray: 256 // Number of shades of gray [2-256]\n\t\t    }, settings || {});\n\t\t\n\t\t    // Get canvas 2d context\n\t\t    var context = canvas.getContext('2d');\n\t\t\n\t\t    // Smoothing\n\t\t    if (context.imageSmoothingEnabled !== undefined) {\n\t\t        context.imageSmoothingEnabled = settings.smoothing;\n\t\t    } else {\n\t\t        context.mozImageSmoothingEnabled = settings.smoothing;\n\t\t        context.webkitImageSmoothingEnabled = settings.smoothing;\n\t\t        context.msImageSmoothingEnabled = settings.smoothing;\n\t\t        context.oImageSmoothingEnabled = settings.smoothing;\n\t\t    }\n\t\t\n\t\t    // Get image data\n\t\t    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\t\t    var data = imageData.data;\n\t\t\n\t\t    var contrastFactor = void 0,\n\t\t        brightnessOffset = void 0,\n\t\t        gammaCorrection = void 0,\n\t\t        shadesOfGrayFactor = void 0;\n\t\t\n\t\t    if (settings.contrast !== 0) {\n\t\t        contrastFactor = 259 * (settings.contrast + 255) / (255 * (259 - settings.contrast));\n\t\t    }\n\t\t\n\t\t    if (settings.brightness !== 0) {\n\t\t        brightnessOffset = settings.brightness;\n\t\t    }\n\t\t\n\t\t    if (settings.gamma !== 0) {\n\t\t        gammaCorrection = 1 / settings.gamma;\n\t\t    }\n\t\t\n\t\t    // Shades of gray\n\t\t    if (settings.shadesOfGray > 1 && settings.shadesOfGray < 256) {\n\t\t        shadesOfGrayFactor = 255 / (settings.shadesOfGray - 1);\n\t\t    }\n\t\t\n\t\t    // For each pixel\n\t\t    for (var i = 0, il = data.length; i < il; i += 4) {\n\t\t        // Apply filters\n\t\t        brightness(data, i, brightnessOffset);\n\t\t        contrast(data, i, contrastFactor);\n\t\t        gamma(data, i, gammaCorrection);\n\t\t        grayscale(data, i, settings.grayscale, shadesOfGrayFactor);\n\t\t    }\n\t\t\n\t\t    // Write new image data on the context\n\t\t    context.putImageData(imageData, 0, 0);\n\t\t}\n\t\t\n\t\t// Exports\n\t\texports.canvasFilters = canvasFilters;\n\t\texports.default = canvasFilters;\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=lw.canvas-filters.js.map\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=lw.canvas-grid.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.canvas-grid/dist/lw.canvas-grid.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}